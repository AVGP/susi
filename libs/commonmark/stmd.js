// stmd.js - CommomMark in JavaScript
// Copyright (C) 2014 John MacFarlane
// License: BSD3.

// Basic usage:
//
// var stmd = require('stmd');
// var parser = new stmd.DocParser();
// var renderer = new stmd.HtmlRenderer();
// console.log(renderer.render(parser.parse('Hello *world*')));

(function(exports) {

    var entities = { AAacute: '√Å',
                     aacute: '√°',
                     Abreve: 'ƒÇ',
                     abreve: 'ƒÉ',
                     ac: '‚àæ',
                     acd: '‚àø',
                     acE: '‚àæ',
                     Acirc: '√Ç',
                     acirc: '√¢',
                     acute: '¬¥',
                     Acy: '–ê',
                     acy: '–∞',
                     AElig: '√Ü',
                     aelig: '√¶',
                     af: '‚Å°',
                     Afr: 'ùîÑ',
                     afr: 'ùîû',
                     Agrave: '√Ä',
                     agrave: '√†',
                     alefsym: '‚Ñµ',
                     aleph: '‚Ñµ',
                     Alpha: 'Œë',
                     alpha: 'Œ±',
                     Amacr: 'ƒÄ',
                     amacr: 'ƒÅ',
                     amalg: '‚®ø',
                     amp: '&',
                     AMP: '&',
                     andand: '‚©ï',
                     And: '‚©ì',
                     and: '‚àß',
                     andd: '‚©ú',
                     andslope: '‚©ò',
                     andv: '‚©ö',
                     ang: '‚à†',
                     ange: '‚¶§',
                     angle: '‚à†',
                     angmsdaa: '‚¶®',
                     angmsdab: '‚¶©',
                     angmsdac: '‚¶™',
                     angmsdad: '‚¶´',
                     angmsdae: '‚¶¨',
                     angmsdaf: '‚¶≠',
                     angmsdag: '‚¶Æ',
                     angmsdah: '‚¶Ø',
                     angmsd: '‚à°',
                     angrt: '‚àü',
                     angrtvb: '‚äæ',
                     angrtvbd: '‚¶ù',
                     angsph: '‚à¢',
                     angst: '√Ö',
                     angzarr: '‚çº',
                     Aogon: 'ƒÑ',
                     aogon: 'ƒÖ',
                     Aopf: 'ùî∏',
                     aopf: 'ùïí',
                     apacir: '‚©Ø',
                     ap: '‚âà',
                     apE: '‚©∞',
                     ape: '‚âä',
                     apid: '‚âã',
                     apos: '\'',
                     ApplyFunction: '‚Å°',
                     approx: '‚âà',
                     approxeq: '‚âä',
                     Aring: '√Ö',
                     aring: '√•',
                     Ascr: 'ùíú',
                     ascr: 'ùí∂',
                     Assign: '‚âî',
                     ast: '*',
                     asymp: '‚âà',
                     asympeq: '‚âç',
                     Atilde: '√É',
                     atilde: '√£',
                     Auml: '√Ñ',
                     auml: '√§',
                     awconint: '‚à≥',
                     awint: '‚®ë',
                     backcong: '‚âå',
                     backepsilon: 'œ∂',
                     backprime: '‚Äµ',
                     backsim: '‚àΩ',
                     backsimeq: '‚ãç',
                     Backslash: '‚àñ',
                     Barv: '‚´ß',
                     barvee: '‚äΩ',
                     barwed: '‚åÖ',
                     Barwed: '‚åÜ',
                     barwedge: '‚åÖ',
                     bbrk: '‚éµ',
                     bbrktbrk: '‚é∂',
                     bcong: '‚âå',
                     Bcy: '–ë',
                     bcy: '–±',
                     bdquo: '‚Äû',
                     becaus: '‚àµ',
                     because: '‚àµ',
                     Because: '‚àµ',
                     bemptyv: '‚¶∞',
                     bepsi: 'œ∂',
                     bernou: '‚Ñ¨',
                     Bernoullis: '‚Ñ¨',
                     Beta: 'Œí',
                     beta: 'Œ≤',
                     beth: '‚Ñ∂',
                     between: '‚â¨',
                     Bfr: 'ùîÖ',
                     bfr: 'ùîü',
                     bigcap: '‚ãÇ',
                     bigcirc: '‚óØ',
                     bigcup: '‚ãÉ',
                     bigodot: '‚®Ä',
                     bigoplus: '‚®Å',
                     bigotimes: '‚®Ç',
                     bigsqcup: '‚®Ü',
                     bigstar: '‚òÖ',
                     bigtriangledown: '‚ñΩ',
                     bigtriangleup: '‚ñ≥',
                     biguplus: '‚®Ñ',
                     bigvee: '‚ãÅ',
                     bigwedge: '‚ãÄ',
                     bkarow: '‚§ç',
                     blacklozenge: '‚ß´',
                     blacksquare: '‚ñ™',
                     blacktriangle: '‚ñ¥',
                     blacktriangledown: '‚ñæ',
                     blacktriangleleft: '‚óÇ',
                     blacktriangleright: '‚ñ∏',
                     blank: '‚ê£',
                     blk12: '‚ñí',
                     blk14: '‚ñë',
                     blk34: '‚ñì',
                     block: '‚ñà',
                     bne: '=',
                     bnequiv: '‚â°',
                     bNot: '‚´≠',
                     bnot: '‚åê',
                     Bopf: 'ùîπ',
                     bopf: 'ùïì',
                     bot: '‚ä•',
                     bottom: '‚ä•',
                     bowtie: '‚ãà',
                     boxbox: '‚ßâ',
                     boxdl: '‚îê',
                     boxdL: '‚ïï',
                     boxDl: '‚ïñ',
                     boxDL: '‚ïó',
                     boxdr: '‚îå',
                     boxdR: '‚ïí',
                     boxDr: '‚ïì',
                     boxDR: '‚ïî',
                     boxh: '‚îÄ',
                     boxH: '‚ïê',
                     boxhd: '‚î¨',
                     boxHd: '‚ï§',
                     boxhD: '‚ï•',
                     boxHD: '‚ï¶',
                     boxhu: '‚î¥',
                     boxHu: '‚ïß',
                     boxhU: '‚ï®',
                     boxHU: '‚ï©',
                     boxminus: '‚äü',
                     boxplus: '‚äû',
                     boxtimes: '‚ä†',
                     boxul: '‚îò',
                     boxuL: '‚ïõ',
                     boxUl: '‚ïú',
                     boxUL: '‚ïù',
                     boxur: '‚îî',
                     boxuR: '‚ïò',
                     boxUr: '‚ïô',
                     boxUR: '‚ïö',
                     boxv: '‚îÇ',
                     boxV: '‚ïë',
                     boxvh: '‚îº',
                     boxvH: '‚ï™',
                     boxVh: '‚ï´',
                     boxVH: '‚ï¨',
                     boxvl: '‚î§',
                     boxvL: '‚ï°',
                     boxVl: '‚ï¢',
                     boxVL: '‚ï£',
                     boxvr: '‚îú',
                     boxvR: '‚ïû',
                     boxVr: '‚ïü',
                     boxVR: '‚ï†',
                     bprime: '‚Äµ',
                     breve: 'Àò',
                     Breve: 'Àò',
                     brvbar: '¬¶',
                     bscr: 'ùí∑',
                     Bscr: '‚Ñ¨',
                     bsemi: '‚Åè',
                     bsim: '‚àΩ',
                     bsime: '‚ãç',
                     bsolb: '‚ßÖ',
                     bsol: '\\',
                     bsolhsub: '‚üà',
                     bull: '‚Ä¢',
                     bullet: '‚Ä¢',
                     bump: '‚âé',
                     bumpE: '‚™Æ',
                     bumpe: '‚âè',
                     Bumpeq: '‚âé',
                     bumpeq: '‚âè',
                     Cacute: 'ƒÜ',
                     cacute: 'ƒá',
                     capand: '‚©Ñ',
                     capbrcup: '‚©â',
                     capcap: '‚©ã',
                     cap: '‚à©',
                     Cap: '‚ãí',
                     capcup: '‚©á',
                     capdot: '‚©Ä',
                     CapitalDifferentialD: '‚ÖÖ',
                     caps: '‚à©',
                     caret: '‚ÅÅ',
                     caron: 'Àá',
                     Cayleys: '‚Ñ≠',
                     ccaps: '‚©ç',
                     Ccaron: 'ƒå',
                     ccaron: 'ƒç',
                     Ccedil: '√á',
                     ccedil: '√ß',
                     Ccirc: 'ƒà',
                     ccirc: 'ƒâ',
                     Cconint: '‚à∞',
                     ccups: '‚©å',
                     ccupssm: '‚©ê',
                     Cdot: 'ƒä',
                     cdot: 'ƒã',
                     cedil: '¬∏',
                     Cedilla: '¬∏',
                     cemptyv: '‚¶≤',
                     cent: '¬¢',
                     centerdot: '¬∑',
                     CenterDot: '¬∑',
                     cfr: 'ùî†',
                     Cfr: '‚Ñ≠',
                     CHcy: '–ß',
                     chcy: '—á',
                     check: '‚úì',
                     checkmark: '‚úì',
                     Chi: 'Œß',
                     chi: 'œá',
                     circ: 'ÀÜ',
                     circeq: '‚âó',
                     circlearrowleft: '‚Ü∫',
                     circlearrowright: '‚Üª',
                     circledast: '‚äõ',
                     circledcirc: '‚äö',
                     circleddash: '‚äù',
                     CircleDot: '‚äô',
                     circledR: '¬Æ',
                     circledS: '‚ìà',
                     CircleMinus: '‚äñ',
                     CirclePlus: '‚äï',
                     CircleTimes: '‚äó',
                     cir: '‚óã',
                     cirE: '‚ßÉ',
                     cire: '‚âó',
                     cirfnint: '‚®ê',
                     cirmid: '‚´Ø',
                     cirscir: '‚ßÇ',
                     ClockwiseContourIntegral: '‚à≤',
                     CloseCurlyDoubleQuote: '‚Äù',
                     CloseCurlyQuote: '‚Äô',
                     clubs: '‚ô£',
                     clubsuit: '‚ô£',
                     colon: ':',
                     Colon: '‚à∑',
                     Colone: '‚©¥',
                     colone: '‚âî',
                     coloneq: '‚âî',
                     comma: ',',
                     commat: '@',
                     comp: '‚àÅ',
                     compfn: '‚àò',
                     complement: '‚àÅ',
                     complexes: '‚ÑÇ',
                     cong: '‚âÖ',
                     congdot: '‚©≠',
                     Congruent: '‚â°',
                     conint: '‚àÆ',
                     Conint: '‚àØ',
                     ContourIntegral: '‚àÆ',
                     copf: 'ùïî',
                     Copf: '‚ÑÇ',
                     coprod: '‚àê',
                     Coproduct: '‚àê',
                     copy: '¬©',
                     COPY: '¬©',
                     copysr: '‚Ñó',
                     CounterClockwiseContourIntegral: '‚à≥',
                     crarr: '‚Üµ',
                     cross: '‚úó',
                     Cross: '‚®Ø',
                     Cscr: 'ùíû',
                     cscr: 'ùí∏',
                     csub: '‚´è',
                     csube: '‚´ë',
                     csup: '‚´ê',
                     csupe: '‚´í',
                     ctdot: '‚ãØ',
                     cudarrl: '‚§∏',
                     cudarrr: '‚§µ',
                     cuepr: '‚ãû',
                     cuesc: '‚ãü',
                     cularr: '‚Ü∂',
                     cularrp: '‚§Ω',
                     cupbrcap: '‚©à',
                     cupcap: '‚©Ü',
                     CupCap: '‚âç',
                     cup: '‚à™',
                     Cup: '‚ãì',
                     cupcup: '‚©ä',
                     cupdot: '‚äç',
                     cupor: '‚©Ö',
                     cups: '‚à™',
                     curarr: '‚Ü∑',
                     curarrm: '‚§º',
                     curlyeqprec: '‚ãû',
                     curlyeqsucc: '‚ãü',
                     curlyvee: '‚ãé',
                     curlywedge: '‚ãè',
                     curren: '¬§',
                     curvearrowleft: '‚Ü∂',
                     curvearrowright: '‚Ü∑',
                     cuvee: '‚ãé',
                     cuwed: '‚ãè',
                     cwconint: '‚à≤',
                     cwint: '‚à±',
                     cylcty: '‚å≠',
                     dagger: '‚Ä†',
                     Dagger: '‚Ä°',
                     daleth: '‚Ñ∏',
                     darr: '‚Üì',
                     Darr: '‚Ü°',
                     dArr: '‚áì',
                     dash: '‚Äê',
                     Dashv: '‚´§',
                     dashv: '‚ä£',
                     dbkarow: '‚§è',
                     dblac: 'Àù',
                     Dcaron: 'ƒé',
                     dcaron: 'ƒè',
                     Dcy: '–î',
                     dcy: '–¥',
                     ddagger: '‚Ä°',
                     ddarr: '‚áä',
                     DD: '‚ÖÖ',
                     dd: '‚ÖÜ',
                     DDotrahd: '‚§ë',
                     ddotseq: '‚©∑',
                     deg: '¬∞',
                     Del: '‚àá',
                     Delta: 'Œî',
                     delta: 'Œ¥',
                     demptyv: '‚¶±',
                     dfisht: '‚•ø',
                     Dfr: 'ùîá',
                     dfr: 'ùî°',
                     dHar: '‚••',
                     dharl: '‚áÉ',
                     dharr: '‚áÇ',
                     DiacriticalAcute: '¬¥',
                     DiacriticalDot: 'Àô',
                     DiacriticalDoubleAcute: 'Àù',
                     DiacriticalGrave: '`',
                     DiacriticalTilde: 'Àú',
                     diam: '‚ãÑ',
                     diamond: '‚ãÑ',
                     Diamond: '‚ãÑ',
                     diamondsuit: '‚ô¶',
                     diams: '‚ô¶',
                     die: '¬®',
                     DifferentialD: '‚ÖÜ',
                     digamma: 'œù',
                     disin: '‚ã≤',
                     div: '√∑',
                     divide: '√∑',
                     divideontimes: '‚ãá',
                     divonx: '‚ãá',
                     DJcy: '–Ç',
                     djcy: '—í',
                     dlcorn: '‚åû',
                     dlcrop: '‚åç',
                     dollar: '$',
                     Dopf: 'ùîª',
                     dopf: 'ùïï',
                     Dot: '¬®',
                     dot: 'Àô',
                     DotDot: '‚Éú',
                     doteq: '‚âê',
                     doteqdot: '‚âë',
                     DotEqual: '‚âê',
                     dotminus: '‚à∏',
                     dotplus: '‚àî',
                     dotsquare: '‚ä°',
                     doublebarwedge: '‚åÜ',
                     DoubleContourIntegral: '‚àØ',
                     DoubleDot: '¬®',
                     DoubleDownArrow: '‚áì',
                     DoubleLeftArrow: '‚áê',
                     DoubleLeftRightArrow: '‚áî',
                     DoubleLeftTee: '‚´§',
                     DoubleLongLeftArrow: '‚ü∏',
                     DoubleLongLeftRightArrow: '‚ü∫',
                     DoubleLongRightArrow: '‚üπ',
                     DoubleRightArrow: '‚áí',
                     DoubleRightTee: '‚ä®',
                     DoubleUpArrow: '‚áë',
                     DoubleUpDownArrow: '‚áï',
                     DoubleVerticalBar: '‚à•',
                     DownArrowBar: '‚§ì',
                     downarrow: '‚Üì',
                     DownArrow: '‚Üì',
                     Downarrow: '‚áì',
                     DownArrowUpArrow: '‚áµ',
                     DownBreve: 'Ãë',
                     downdownarrows: '‚áä',
                     downharpoonleft: '‚áÉ',
                     downharpoonright: '‚áÇ',
                     DownLeftRightVector: '‚•ê',
                     DownLeftTeeVector: '‚•û',
                     DownLeftVectorBar: '‚•ñ',
                     DownLeftVector: '‚ÜΩ',
                     DownRightTeeVector: '‚•ü',
                     DownRightVectorBar: '‚•ó',
                     DownRightVector: '‚áÅ',
                     DownTeeArrow: '‚Üß',
                     DownTee: '‚ä§',
                     drbkarow: '‚§ê',
                     drcorn: '‚åü',
                     drcrop: '‚åå',
                     Dscr: 'ùíü',
                     dscr: 'ùíπ',
                     DScy: '–Ö',
                     dscy: '—ï',
                     dsol: '‚ß∂',
                     Dstrok: 'ƒê',
                     dstrok: 'ƒë',
                     dtdot: '‚ã±',
                     dtri: '‚ñø',
                     dtrif: '‚ñæ',
                     duarr: '‚áµ',
                     duhar: '‚•Ø',
                     dwangle: '‚¶¶',
                     DZcy: '–è',
                     dzcy: '—ü',
                     dzigrarr: '‚üø',
                     Eacute: '√â',
                     eacute: '√©',
                     easter: '‚©Æ',
                     Ecaron: 'ƒö',
                     ecaron: 'ƒõ',
                     Ecirc: '√ä',
                     ecirc: '√™',
                     ecir: '‚âñ',
                     ecolon: '‚âï',
                     Ecy: '–≠',
                     ecy: '—ç',
                     eDDot: '‚©∑',
                     Edot: 'ƒñ',
                     edot: 'ƒó',
                     eDot: '‚âë',
                     ee: '‚Öá',
                     efDot: '‚âí',
                     Efr: 'ùîà',
                     efr: 'ùî¢',
                     eg: '‚™ö',
                     Egrave: '√à',
                     egrave: '√®',
                     egs: '‚™ñ',
                     egsdot: '‚™ò',
                     el: '‚™ô',
                     Element: '‚àà',
                     elinters: '‚èß',
                     ell: '‚Ñì',
                     els: '‚™ï',
                     elsdot: '‚™ó',
                     Emacr: 'ƒí',
                     emacr: 'ƒì',
                     empty: '‚àÖ',
                     emptyset: '‚àÖ',
                     EmptySmallSquare: '‚óª',
                     emptyv: '‚àÖ',
                     EmptyVerySmallSquare: '‚ñ´',
                     emsp13: '‚ÄÑ',
                     emsp14: '‚ÄÖ',
                     emsp: '‚ÄÉ',
                     ENG: '≈ä',
                     eng: '≈ã',
                     ensp: '‚ÄÇ',
                     Eogon: 'ƒò',
                     eogon: 'ƒô',
                     Eopf: 'ùîº',
                     eopf: 'ùïñ',
                     epar: '‚ãï',
                     eparsl: '‚ß£',
                     eplus: '‚©±',
                     epsi: 'Œµ',
                     Epsilon: 'Œï',
                     epsilon: 'Œµ',
                     epsiv: 'œµ',
                     eqcirc: '‚âñ',
                     eqcolon: '‚âï',
                     eqsim: '‚âÇ',
                     eqslantgtr: '‚™ñ',
                     eqslantless: '‚™ï',
                     Equal: '‚©µ',
                     equals: '=',
                     EqualTilde: '‚âÇ',
                     equest: '‚âü',
                     Equilibrium: '‚áå',
                     equiv: '‚â°',
                     equivDD: '‚©∏',
                     eqvparsl: '‚ß•',
                     erarr: '‚•±',
                     erDot: '‚âì',
                     escr: '‚ÑØ',
                     Escr: '‚Ñ∞',
                     esdot: '‚âê',
                     Esim: '‚©≥',
                     esim: '‚âÇ',
                     Eta: 'Œó',
                     eta: 'Œ∑',
                     ETH: '√ê',
                     eth: '√∞',
                     Euml: '√ã',
                     euml: '√´',
                     euro: '‚Ç¨',
                     excl: '!',
                     exist: '‚àÉ',
                     Exists: '‚àÉ',
                     expectation: '‚Ñ∞',
                     exponentiale: '‚Öá',
                     ExponentialE: '‚Öá',
                     fallingdotseq: '‚âí',
                     Fcy: '–§',
                     fcy: '—Ñ',
                     female: '‚ôÄ',
                     ffilig: 'Ô¨É',
                     fflig: 'Ô¨Ä',
                     ffllig: 'Ô¨Ñ',
                     Ffr: 'ùîâ',
                     ffr: 'ùî£',
                     filig: 'Ô¨Å',
                     FilledSmallSquare: '‚óº',
                     FilledVerySmallSquare: '‚ñ™',
                     fjlig: 'f',
                     flat: '‚ô≠',
                     fllig: 'Ô¨Ç',
                     fltns: '‚ñ±',
                     fnof: '∆í',
                     Fopf: 'ùîΩ',
                     fopf: 'ùïó',
                     forall: '‚àÄ',
                     ForAll: '‚àÄ',
                     fork: '‚ãî',
                     forkv: '‚´ô',
                     Fouriertrf: '‚Ñ±',
                     fpartint: '‚®ç',
                     frac12: '¬Ω',
                     frac13: '‚Öì',
                     frac14: '¬º',
                     frac15: '‚Öï',
                     frac16: '‚Öô',
                     frac18: '‚Öõ',
                     frac23: '‚Öî',
                     frac25: '‚Öñ',
                     frac34: '¬æ',
                     frac35: '‚Öó',
                     frac38: '‚Öú',
                     frac45: '‚Öò',
                     frac56: '‚Öö',
                     frac58: '‚Öù',
                     frac78: '‚Öû',
                     frasl: '‚ÅÑ',
                     frown: '‚å¢',
                     fscr: 'ùíª',
                     Fscr: '‚Ñ±',
                     gacute: '«µ',
                     Gamma: 'Œì',
                     gamma: 'Œ≥',
                     Gammad: 'œú',
                     gammad: 'œù',
                     gap: '‚™Ü',
                     Gbreve: 'ƒû',
                     gbreve: 'ƒü',
                     Gcedil: 'ƒ¢',
                     Gcirc: 'ƒú',
                     gcirc: 'ƒù',
                     Gcy: '–ì',
                     gcy: '–≥',
                     Gdot: 'ƒ†',
                     gdot: 'ƒ°',
                     ge: '‚â•',
                     gE: '‚âß',
                     gEl: '‚™å',
                     gel: '‚ãõ',
                     geq: '‚â•',
                     geqq: '‚âß',
                     geqslant: '‚©æ',
                     gescc: '‚™©',
                     ges: '‚©æ',
                     gesdot: '‚™Ä',
                     gesdoto: '‚™Ç',
                     gesdotol: '‚™Ñ',
                     gesl: '‚ãõ',
                     gesles: '‚™î',
                     Gfr: 'ùîä',
                     gfr: 'ùî§',
                     gg: '‚â´',
                     Gg: '‚ãô',
                     ggg: '‚ãô',
                     gimel: '‚Ñ∑',
                     GJcy: '–É',
                     gjcy: '—ì',
                     gla: '‚™•',
                     gl: '‚â∑',
                     glE: '‚™í',
                     glj: '‚™§',
                     gnap: '‚™ä',
                     gnapprox: '‚™ä',
                     gne: '‚™à',
                     gnE: '‚â©',
                     gneq: '‚™à',
                     gneqq: '‚â©',
                     gnsim: '‚ãß',
                     Gopf: 'ùîæ',
                     gopf: 'ùïò',
                     grave: '`',
                     GreaterEqual: '‚â•',
                     GreaterEqualLess: '‚ãõ',
                     GreaterFullEqual: '‚âß',
                     GreaterGreater: '‚™¢',
                     GreaterLess: '‚â∑',
                     GreaterSlantEqual: '‚©æ',
                     GreaterTilde: '‚â≥',
                     Gscr: 'ùí¢',
                     gscr: '‚Ñä',
                     gsim: '‚â≥',
                     gsime: '‚™é',
                     gsiml: '‚™ê',
                     gtcc: '‚™ß',
                     gtcir: '‚©∫',
                     gt: '>',
                     GT: '>',
                     Gt: '‚â´',
                     gtdot: '‚ãó',
                     gtlPar: '‚¶ï',
                     gtquest: '‚©º',
                     gtrapprox: '‚™Ü',
                     gtrarr: '‚•∏',
                     gtrdot: '‚ãó',
                     gtreqless: '‚ãõ',
                     gtreqqless: '‚™å',
                     gtrless: '‚â∑',
                     gtrsim: '‚â≥',
                     gvertneqq: '‚â©',
                     gvnE: '‚â©',
                     Hacek: 'Àá',
                     hairsp: '‚Ää',
                     half: '¬Ω',
                     hamilt: '‚Ñã',
                     HARDcy: '–™',
                     hardcy: '—ä',
                     harrcir: '‚•à',
                     harr: '‚Üî',
                     hArr: '‚áî',
                     harrw: '‚Ü≠',
                     Hat: '^',
                     hbar: '‚Ñè',
                     Hcirc: 'ƒ§',
                     hcirc: 'ƒ•',
                     hearts: '‚ô•',
                     heartsuit: '‚ô•',
                     hellip: '‚Ä¶',
                     hercon: '‚äπ',
                     hfr: 'ùî•',
                     Hfr: '‚Ñå',
                     HilbertSpace: '‚Ñã',
                     hksearow: '‚§•',
                     hkswarow: '‚§¶',
                     hoarr: '‚áø',
                     homtht: '‚àª',
                     hookleftarrow: '‚Ü©',
                     hookrightarrow: '‚Ü™',
                     hopf: 'ùïô',
                     Hopf: '‚Ñç',
                     horbar: '‚Äï',
                     HorizontalLine: '‚îÄ',
                     hscr: 'ùíΩ',
                     Hscr: '‚Ñã',
                     hslash: '‚Ñè',
                     Hstrok: 'ƒ¶',
                     hstrok: 'ƒß',
                     HumpDownHump: '‚âé',
                     HumpEqual: '‚âè',
                     hybull: '‚ÅÉ',
                     hyphen: '‚Äê',
                     Iacute: '√ç',
                     iacute: '√≠',
                     ic: '‚Å£',
                     Icirc: '√é',
                     icirc: '√Æ',
                     Icy: '–ò',
                     icy: '–∏',
                     Idot: 'ƒ∞',
                     IEcy: '–ï',
                     iecy: '–µ',
                     iexcl: '¬°',
                     iff: '‚áî',
                     ifr: 'ùî¶',
                     Ifr: '‚Ñë',
                     Igrave: '√å',
                     igrave: '√¨',
                     ii: '‚Öà',
                     iiiint: '‚®å',
                     iiint: '‚à≠',
                     iinfin: '‚ßú',
                     iiota: '‚Ñ©',
                     IJlig: 'ƒ≤',
                     ijlig: 'ƒ≥',
                     Imacr: 'ƒ™',
                     imacr: 'ƒ´',
                     image: '‚Ñë',
                     ImaginaryI: '‚Öà',
                     imagline: '‚Ñê',
                     imagpart: '‚Ñë',
                     imath: 'ƒ±',
                     Im: '‚Ñë',
                     imof: '‚ä∑',
                     imped: '∆µ',
                     Implies: '‚áí',
                     incare: '‚ÑÖ',
                     in: '‚àà',
                     infin: '‚àû',
                     infintie: '‚ßù',
                     inodot: 'ƒ±',
                     intcal: '‚ä∫',
                     int: '‚à´',
                     Int: '‚à¨',
                     integers: '‚Ñ§',
                     Integral: '‚à´',
                     intercal: '‚ä∫',
                     Intersection: '‚ãÇ',
                     intlarhk: '‚®ó',
                     intprod: '‚®º',
                     InvisibleComma: '‚Å£',
                     InvisibleTimes: '‚Å¢',
                     IOcy: '–Å',
                     iocy: '—ë',
                     Iogon: 'ƒÆ',
                     iogon: 'ƒØ',
                     Iopf: 'ùïÄ',
                     iopf: 'ùïö',
                     Iota: 'Œô',
                     iota: 'Œπ',
                     iprod: '‚®º',
                     iquest: '¬ø',
                     iscr: 'ùíæ',
                     Iscr: '‚Ñê',
                     isin: '‚àà',
                     isindot: '‚ãµ',
                     isinE: '‚ãπ',
                     isins: '‚ã¥',
                     isinsv: '‚ã≥',
                     isinv: '‚àà',
                     it: '‚Å¢',
                     Itilde: 'ƒ®',
                     itilde: 'ƒ©',
                     Iukcy: '–Ü',
                     iukcy: '—ñ',
                     Iuml: '√è',
                     iuml: '√Ø',
                     Jcirc: 'ƒ¥',
                     jcirc: 'ƒµ',
                     Jcy: '–ô',
                     jcy: '–π',
                     Jfr: 'ùîç',
                     jfr: 'ùîß',
                     jmath: '»∑',
                     Jopf: 'ùïÅ',
                     jopf: 'ùïõ',
                     Jscr: 'ùí•',
                     jscr: 'ùíø',
                     Jsercy: '–à',
                     jsercy: '—ò',
                     Jukcy: '–Ñ',
                     jukcy: '—î',
                     Kappa: 'Œö',
                     kappa: 'Œ∫',
                     kappav: 'œ∞',
                     Kcedil: 'ƒ∂',
                     kcedil: 'ƒ∑',
                     Kcy: '–ö',
                     kcy: '–∫',
                     Kfr: 'ùîé',
                     kfr: 'ùî®',
                     kgreen: 'ƒ∏',
                     KHcy: '–•',
                     khcy: '—Ö',
                     KJcy: '–å',
                     kjcy: '—ú',
                     Kopf: 'ùïÇ',
                     kopf: 'ùïú',
                     Kscr: 'ùí¶',
                     kscr: 'ùìÄ',
                     lAarr: '‚áö',
                     Lacute: 'ƒπ',
                     lacute: 'ƒ∫',
                     laemptyv: '‚¶¥',
                     lagran: '‚Ñí',
                     Lambda: 'Œõ',
                     lambda: 'Œª',
                     lang: '‚ü®',
                     Lang: '‚ü™',
                     langd: '‚¶ë',
                     langle: '‚ü®',
                     lap: '‚™Ö',
                     Laplacetrf: '‚Ñí',
                     laquo: '¬´',
                     larrb: '‚á§',
                     larrbfs: '‚§ü',
                     larr: '‚Üê',
                     Larr: '‚Üû',
                     lArr: '‚áê',
                     larrfs: '‚§ù',
                     larrhk: '‚Ü©',
                     larrlp: '‚Ü´',
                     larrpl: '‚§π',
                     larrsim: '‚•≥',
                     larrtl: '‚Ü¢',
                     latail: '‚§ô',
                     lAtail: '‚§õ',
                     lat: '‚™´',
                     late: '‚™≠',
                     lates: '‚™≠',
                     lbarr: '‚§å',
                     lBarr: '‚§é',
                     lbbrk: '‚ù≤',
                     lbrace: '{',
                     lbrack: '[',
                     lbrke: '‚¶ã',
                     lbrksld: '‚¶è',
                     lbrkslu: '‚¶ç',
                     Lcaron: 'ƒΩ',
                     lcaron: 'ƒæ',
                     Lcedil: 'ƒª',
                     lcedil: 'ƒº',
                     lceil: '‚åà',
                     lcub: '{',
                     Lcy: '–õ',
                     lcy: '–ª',
                     ldca: '‚§∂',
                     ldquo: '‚Äú',
                     ldquor: '‚Äû',
                     ldrdhar: '‚•ß',
                     ldrushar: '‚•ã',
                     ldsh: '‚Ü≤',
                     le: '‚â§',
                     lE: '‚â¶',
                     LeftAngleBracket: '‚ü®',
                     LeftArrowBar: '‚á§',
                     leftarrow: '‚Üê',
                     LeftArrow: '‚Üê',
                     Leftarrow: '‚áê',
                     LeftArrowRightArrow: '‚áÜ',
                     leftarrowtail: '‚Ü¢',
                     LeftCeiling: '‚åà',
                     LeftDoubleBracket: '‚ü¶',
                     LeftDownTeeVector: '‚•°',
                     LeftDownVectorBar: '‚•ô',
                     LeftDownVector: '‚áÉ',
                     LeftFloor: '‚åä',
                     leftharpoondown: '‚ÜΩ',
                     leftharpoonup: '‚Üº',
                     leftleftarrows: '‚áá',
                     leftrightarrow: '‚Üî',
                     LeftRightArrow: '‚Üî',
                     Leftrightarrow: '‚áî',
                     leftrightarrows: '‚áÜ',
                     leftrightharpoons: '‚áã',
                     leftrightsquigarrow: '‚Ü≠',
                     LeftRightVector: '‚•é',
                     LeftTeeArrow: '‚Ü§',
                     LeftTee: '‚ä£',
                     LeftTeeVector: '‚•ö',
                     leftthreetimes: '‚ãã',
                     LeftTriangleBar: '‚ßè',
                     LeftTriangle: '‚ä≤',
                     LeftTriangleEqual: '‚ä¥',
                     LeftUpDownVector: '‚•ë',
                     LeftUpTeeVector: '‚•†',
                     LeftUpVectorBar: '‚•ò',
                     LeftUpVector: '‚Üø',
                     LeftVectorBar: '‚•í',
                     LeftVector: '‚Üº',
                     lEg: '‚™ã',
                     leg: '‚ãö',
                     leq: '‚â§',
                     leqq: '‚â¶',
                     leqslant: '‚©Ω',
                     lescc: '‚™®',
                     les: '‚©Ω',
                     lesdot: '‚©ø',
                     lesdoto: '‚™Å',
                     lesdotor: '‚™É',
                     lesg: '‚ãö',
                     lesges: '‚™ì',
                     lessapprox: '‚™Ö',
                     lessdot: '‚ãñ',
                     lesseqgtr: '‚ãö',
                     lesseqqgtr: '‚™ã',
                     LessEqualGreater: '‚ãö',
                     LessFullEqual: '‚â¶',
                     LessGreater: '‚â∂',
                     lessgtr: '‚â∂',
                     LessLess: '‚™°',
                     lesssim: '‚â≤',
                     LessSlantEqual: '‚©Ω',
                     LessTilde: '‚â≤',
                     lfisht: '‚•º',
                     lfloor: '‚åä',
                     Lfr: 'ùîè',
                     lfr: 'ùî©',
                     lg: '‚â∂',
                     lgE: '‚™ë',
                     lHar: '‚•¢',
                     lhard: '‚ÜΩ',
                     lharu: '‚Üº',
                     lharul: '‚•™',
                     lhblk: '‚ñÑ',
                     LJcy: '–â',
                     ljcy: '—ô',
                     llarr: '‚áá',
                     ll: '‚â™',
                     Ll: '‚ãò',
                     llcorner: '‚åû',
                     Lleftarrow: '‚áö',
                     llhard: '‚•´',
                     lltri: '‚ó∫',
                     Lmidot: 'ƒø',
                     lmidot: '≈Ä',
                     lmoustache: '‚é∞',
                     lmoust: '‚é∞',
                     lnap: '‚™â',
                     lnapprox: '‚™â',
                     lne: '‚™á',
                     lnE: '‚â®',
                     lneq: '‚™á',
                     lneqq: '‚â®',
                     lnsim: '‚ã¶',
                     loang: '‚ü¨',
                     loarr: '‚áΩ',
                     lobrk: '‚ü¶',
                     longleftarrow: '‚üµ',
                     LongLeftArrow: '‚üµ',
                     Longleftarrow: '‚ü∏',
                     longleftrightarrow: '‚ü∑',
                     LongLeftRightArrow: '‚ü∑',
                     Longleftrightarrow: '‚ü∫',
                     longmapsto: '‚üº',
                     longrightarrow: '‚ü∂',
                     LongRightArrow: '‚ü∂',
                     Longrightarrow: '‚üπ',
                     looparrowleft: '‚Ü´',
                     looparrowright: '‚Ü¨',
                     lopar: '‚¶Ö',
                     Lopf: 'ùïÉ',
                     lopf: 'ùïù',
                     loplus: '‚®≠',
                     lotimes: '‚®¥',
                     lowast: '‚àó',
                     lowbar: '_',
                     LowerLeftArrow: '‚Üô',
                     LowerRightArrow: '‚Üò',
                     loz: '‚óä',
                     lozenge: '‚óä',
                     lozf: '‚ß´',
                     lpar: '(',
                     lparlt: '‚¶ì',
                     lrarr: '‚áÜ',
                     lrcorner: '‚åü',
                     lrhar: '‚áã',
                     lrhard: '‚•≠',
                     lrm: '‚Äé',
                     lrtri: '‚äø',
                     lsaquo: '‚Äπ',
                     lscr: 'ùìÅ',
                     Lscr: '‚Ñí',
                     lsh: '‚Ü∞',
                     Lsh: '‚Ü∞',
                     lsim: '‚â≤',
                     lsime: '‚™ç',
                     lsimg: '‚™è',
                     lsqb: '[',
                     lsquo: '‚Äò',
                     lsquor: '‚Äö',
                     Lstrok: '≈Å',
                     lstrok: '≈Ç',
                     ltcc: '‚™¶',
                     ltcir: '‚©π',
                     lt: '<',
                     LT: '<',
                     Lt: '‚â™',
                     ltdot: '‚ãñ',
                     lthree: '‚ãã',
                     ltimes: '‚ãâ',
                     ltlarr: '‚•∂',
                     ltquest: '‚©ª',
                     ltri: '‚óÉ',
                     ltrie: '‚ä¥',
                     ltrif: '‚óÇ',
                     ltrPar: '‚¶ñ',
                     lurdshar: '‚•ä',
                     luruhar: '‚•¶',
                     lvertneqq: '‚â®',
                     lvnE: '‚â®',
                     macr: '¬Ø',
                     male: '‚ôÇ',
                     malt: '‚ú†',
                     maltese: '‚ú†',
                     Map: '‚§Ö',
                     map: '‚Ü¶',
                     mapsto: '‚Ü¶',
                     mapstodown: '‚Üß',
                     mapstoleft: '‚Ü§',
                     mapstoup: '‚Ü•',
                     marker: '‚ñÆ',
                     mcomma: '‚®©',
                     Mcy: '–ú',
                     mcy: '–º',
                     mdash: '‚Äî',
                     mDDot: '‚à∫',
                     measuredangle: '‚à°',
                     MediumSpace: '‚Åü',
                     Mellintrf: '‚Ñ≥',
                     Mfr: 'ùîê',
                     mfr: 'ùî™',
                     mho: '‚Ñß',
                     micro: '¬µ',
                     midast: '*',
                     midcir: '‚´∞',
                     mid: '‚à£',
                     middot: '¬∑',
                     minusb: '‚äü',
                     minus: '‚àí',
                     minusd: '‚à∏',
                     minusdu: '‚®™',
                     MinusPlus: '‚àì',
                     mlcp: '‚´õ',
                     mldr: '‚Ä¶',
                     mnplus: '‚àì',
                     models: '‚äß',
                     Mopf: 'ùïÑ',
                     mopf: 'ùïû',
                     mp: '‚àì',
                     mscr: 'ùìÇ',
                     Mscr: '‚Ñ≥',
                     mstpos: '‚àæ',
                     Mu: 'Œú',
                     mu: 'Œº',
                     multimap: '‚ä∏',
                     mumap: '‚ä∏',
                     nabla: '‚àá',
                     Nacute: '≈É',
                     nacute: '≈Ñ',
                     nang: '‚à†',
                     nap: '‚ââ',
                     napE: '‚©∞',
                     napid: '‚âã',
                     napos: '≈â',
                     napprox: '‚ââ',
                     natural: '‚ôÆ',
                     naturals: '‚Ñï',
                     natur: '‚ôÆ',
                     nbsp: '¬†',
                     nbump: '‚âé',
                     nbumpe: '‚âè',
                     ncap: '‚©É',
                     Ncaron: '≈á',
                     ncaron: '≈à',
                     Ncedil: '≈Ö',
                     ncedil: '≈Ü',
                     ncong: '‚âá',
                     ncongdot: '‚©≠',
                     ncup: '‚©Ç',
                     Ncy: '–ù',
                     ncy: '–Ω',
                     ndash: '‚Äì',
                     nearhk: '‚§§',
                     nearr: '‚Üó',
                     neArr: '‚áó',
                     nearrow: '‚Üó',
                     ne: '‚â†',
                     nedot: '‚âê',
                     NegativeMediumSpace: '‚Äã',
                     NegativeThickSpace: '‚Äã',
                     NegativeThinSpace: '‚Äã',
                     NegativeVeryThinSpace: '‚Äã',
                     nequiv: '‚â¢',
                     nesear: '‚§®',
                     nesim: '‚âÇ',
                     NestedGreaterGreater: '‚â´',
                     NestedLessLess: '‚â™',
                     NewLine: '\n',
                     nexist: '‚àÑ',
                     nexists: '‚àÑ',
                     Nfr: 'ùîë',
                     nfr: 'ùî´',
                     ngE: '‚âß',
                     nge: '‚â±',
                     ngeq: '‚â±',
                     ngeqq: '‚âß',
                     ngeqslant: '‚©æ',
                     nges: '‚©æ',
                     nGg: '‚ãô',
                     ngsim: '‚âµ',
                     nGt: '‚â´',
                     ngt: '‚âØ',
                     ngtr: '‚âØ',
                     nGtv: '‚â´',
                     nharr: '‚ÜÆ',
                     nhArr: '‚áé',
                     nhpar: '‚´≤',
                     ni: '‚àã',
                     nis: '‚ãº',
                     nisd: '‚ã∫',
                     niv: '‚àã',
                     NJcy: '–ä',
                     njcy: '—ö',
                     nlarr: '‚Üö',
                     nlArr: '‚áç',
                     nldr: '‚Ä•',
                     nlE: '‚â¶',
                     nle: '‚â∞',
                     nleftarrow: '‚Üö',
                     nLeftarrow: '‚áç',
                     nleftrightarrow: '‚ÜÆ',
                     nLeftrightarrow: '‚áé',
                     nleq: '‚â∞',
                     nleqq: '‚â¶',
                     nleqslant: '‚©Ω',
                     nles: '‚©Ω',
                     nless: '‚âÆ',
                     nLl: '‚ãò',
                     nlsim: '‚â¥',
                     nLt: '‚â™',
                     nlt: '‚âÆ',
                     nltri: '‚ã™',
                     nltrie: '‚ã¨',
                     nLtv: '‚â™',
                     nmid: '‚à§',
                     NoBreak: '‚Å†',
                     NonBreakingSpace: '¬†',
                     nopf: 'ùïü',
                     Nopf: '‚Ñï',
                     Not: '‚´¨',
                     not: '¬¨',
                     NotCongruent: '‚â¢',
                     NotCupCap: '‚â≠',
                     NotDoubleVerticalBar: '‚à¶',
                     NotElement: '‚àâ',
                     NotEqual: '‚â†',
                     NotEqualTilde: '‚âÇ',
                     NotExists: '‚àÑ',
                     NotGreater: '‚âØ',
                     NotGreaterEqual: '‚â±',
                     NotGreaterFullEqual: '‚âß',
                     NotGreaterGreater: '‚â´',
                     NotGreaterLess: '‚âπ',
                     NotGreaterSlantEqual: '‚©æ',
                     NotGreaterTilde: '‚âµ',
                     NotHumpDownHump: '‚âé',
                     NotHumpEqual: '‚âè',
                     notin: '‚àâ',
                     notindot: '‚ãµ',
                     notinE: '‚ãπ',
                     notinva: '‚àâ',
                     notinvb: '‚ã∑',
                     notinvc: '‚ã∂',
                     NotLeftTriangleBar: '‚ßè',
                     NotLeftTriangle: '‚ã™',
                     NotLeftTriangleEqual: '‚ã¨',
                     NotLess: '‚âÆ',
                     NotLessEqual: '‚â∞',
                     NotLessGreater: '‚â∏',
                     NotLessLess: '‚â™',
                     NotLessSlantEqual: '‚©Ω',
                     NotLessTilde: '‚â¥',
                     NotNestedGreaterGreater: '‚™¢',
                     NotNestedLessLess: '‚™°',
                     notni: '‚àå',
                     notniva: '‚àå',
                     notnivb: '‚ãæ',
                     notnivc: '‚ãΩ',
                     NotPrecedes: '‚äÄ',
                     NotPrecedesEqual: '‚™Ø',
                     NotPrecedesSlantEqual: '‚ã†',
                     NotReverseElement: '‚àå',
                     NotRightTriangleBar: '‚ßê',
                     NotRightTriangle: '‚ã´',
                     NotRightTriangleEqual: '‚ã≠',
                     NotSquareSubset: '‚äè',
                     NotSquareSubsetEqual: '‚ã¢',
                     NotSquareSuperset: '‚äê',
                     NotSquareSupersetEqual: '‚ã£',
                     NotSubset: '‚äÇ',
                     NotSubsetEqual: '‚äà',
                     NotSucceeds: '‚äÅ',
                     NotSucceedsEqual: '‚™∞',
                     NotSucceedsSlantEqual: '‚ã°',
                     NotSucceedsTilde: '‚âø',
                     NotSuperset: '‚äÉ',
                     NotSupersetEqual: '‚äâ',
                     NotTilde: '‚âÅ',
                     NotTildeEqual: '‚âÑ',
                     NotTildeFullEqual: '‚âá',
                     NotTildeTilde: '‚ââ',
                     NotVerticalBar: '‚à§',
                     nparallel: '‚à¶',
                     npar: '‚à¶',
                     nparsl: '‚´Ω',
                     npart: '‚àÇ',
                     npolint: '‚®î',
                     npr: '‚äÄ',
                     nprcue: '‚ã†',
                     nprec: '‚äÄ',
                     npreceq: '‚™Ø',
                     npre: '‚™Ø',
                     nrarrc: '‚§≥',
                     nrarr: '‚Üõ',
                     nrArr: '‚áè',
                     nrarrw: '‚Üù',
                     nrightarrow: '‚Üõ',
                     nRightarrow: '‚áè',
                     nrtri: '‚ã´',
                     nrtrie: '‚ã≠',
                     nsc: '‚äÅ',
                     nsccue: '‚ã°',
                     nsce: '‚™∞',
                     Nscr: 'ùí©',
                     nscr: 'ùìÉ',
                     nshortmid: '‚à§',
                     nshortparallel: '‚à¶',
                     nsim: '‚âÅ',
                     nsime: '‚âÑ',
                     nsimeq: '‚âÑ',
                     nsmid: '‚à§',
                     nspar: '‚à¶',
                     nsqsube: '‚ã¢',
                     nsqsupe: '‚ã£',
                     nsub: '‚äÑ',
                     nsubE: '‚´Ö',
                     nsube: '‚äà',
                     nsubset: '‚äÇ',
                     nsubseteq: '‚äà',
                     nsubseteqq: '‚´Ö',
                     nsucc: '‚äÅ',
                     nsucceq: '‚™∞',
                     nsup: '‚äÖ',
                     nsupE: '‚´Ü',
                     nsupe: '‚äâ',
                     nsupset: '‚äÉ',
                     nsupseteq: '‚äâ',
                     nsupseteqq: '‚´Ü',
                     ntgl: '‚âπ',
                     Ntilde: '√ë',
                     ntilde: '√±',
                     ntlg: '‚â∏',
                     ntriangleleft: '‚ã™',
                     ntrianglelefteq: '‚ã¨',
                     ntriangleright: '‚ã´',
                     ntrianglerighteq: '‚ã≠',
                     Nu: 'Œù',
                     nu: 'ŒΩ',
                     num: '#',
                     numero: '‚Ññ',
                     numsp: '‚Äá',
                     nvap: '‚âç',
                     nvdash: '‚ä¨',
                     nvDash: '‚ä≠',
                     nVdash: '‚äÆ',
                     nVDash: '‚äØ',
                     nvge: '‚â•',
                     nvgt: '>',
                     nvHarr: '‚§Ñ',
                     nvinfin: '‚ßû',
                     nvlArr: '‚§Ç',
                     nvle: '‚â§',
                     nvlt: '>',
                     nvltrie: '‚ä¥',
                     nvrArr: '‚§É',
                     nvrtrie: '‚äµ',
                     nvsim: '‚àº',
                     nwarhk: '‚§£',
                     nwarr: '‚Üñ',
                     nwArr: '‚áñ',
                     nwarrow: '‚Üñ',
                     nwnear: '‚§ß',
                     Oacute: '√ì',
                     oacute: '√≥',
                     oast: '‚äõ',
                     Ocirc: '√î',
                     ocirc: '√¥',
                     ocir: '‚äö',
                     Ocy: '–û',
                     ocy: '–æ',
                     odash: '‚äù',
                     Odblac: '≈ê',
                     odblac: '≈ë',
                     odiv: '‚®∏',
                     odot: '‚äô',
                     odsold: '‚¶º',
                     OElig: '≈í',
                     oelig: '≈ì',
                     ofcir: '‚¶ø',
                     Ofr: 'ùîí',
                     ofr: 'ùî¨',
                     ogon: 'Àõ',
                     Ograve: '√í',
                     ograve: '√≤',
                     ogt: '‚ßÅ',
                     ohbar: '‚¶µ',
                     ohm: 'Œ©',
                     oint: '‚àÆ',
                     olarr: '‚Ü∫',
                     olcir: '‚¶æ',
                     olcross: '‚¶ª',
                     oline: '‚Äæ',
                     olt: '‚ßÄ',
                     Omacr: '≈å',
                     omacr: '≈ç',
                     Omega: 'Œ©',
                     omega: 'œâ',
                     Omicron: 'Œü',
                     omicron: 'Œø',
                     omid: '‚¶∂',
                     ominus: '‚äñ',
                     Oopf: 'ùïÜ',
                     oopf: 'ùï†',
                     opar: '‚¶∑',
                     OpenCurlyDoubleQuote: '‚Äú',
                     OpenCurlyQuote: '‚Äò',
                     operp: '‚¶π',
                     oplus: '‚äï',
                     orarr: '‚Üª',
                     Or: '‚©î',
                     or: '‚à®',
                     ord: '‚©ù',
                     order: '‚Ñ¥',
                     orderof: '‚Ñ¥',
                     ordf: '¬™',
                     ordm: '¬∫',
                     origof: '‚ä∂',
                     oror: '‚©ñ',
                     orslope: '‚©ó',
                     orv: '‚©õ',
                     oS: '‚ìà',
                     Oscr: 'ùí™',
                     oscr: '‚Ñ¥',
                     Oslash: '√ò',
                     oslash: '√∏',
                     osol: '‚äò',
                     Otilde: '√ï',
                     otilde: '√µ',
                     otimesas: '‚®∂',
                     Otimes: '‚®∑',
                     otimes: '‚äó',
                     Ouml: '√ñ',
                     ouml: '√∂',
                     ovbar: '‚åΩ',
                     OverBar: '‚Äæ',
                     OverBrace: '‚èû',
                     OverBracket: '‚é¥',
                     OverParenthesis: '‚èú',
                     para: '¬∂',
                     parallel: '‚à•',
                     par: '‚à•',
                     parsim: '‚´≥',
                     parsl: '‚´Ω',
                     part: '‚àÇ',
                     PartialD: '‚àÇ',
                     Pcy: '–ü',
                     pcy: '–ø',
                     percnt: '%',
                     period: '.',
                     permil: '‚Ä∞',
                     perp: '‚ä•',
                     pertenk: '‚Ä±',
                     Pfr: 'ùîì',
                     pfr: 'ùî≠',
                     Phi: 'Œ¶',
                     phi: 'œÜ',
                     phiv: 'œï',
                     phmmat: '‚Ñ≥',
                     phone: '‚òé',
                     Pi: 'Œ†',
                     pi: 'œÄ',
                     pitchfork: '‚ãî',
                     piv: 'œñ',
                     planck: '‚Ñè',
                     planckh: '‚Ñé',
                     plankv: '‚Ñè',
                     plusacir: '‚®£',
                     plusb: '‚äû',
                     pluscir: '‚®¢',
                     plus: '+',
                     plusdo: '‚àî',
                     plusdu: '‚®•',
                     pluse: '‚©≤',
                     PlusMinus: '¬±',
                     plusmn: '¬±',
                     plussim: '‚®¶',
                     plustwo: '‚®ß',
                     pm: '¬±',
                     Poincareplane: '‚Ñå',
                     pointint: '‚®ï',
                     popf: 'ùï°',
                     Popf: '‚Ñô',
                     pound: '¬£',
                     prap: '‚™∑',
                     Pr: '‚™ª',
                     pr: '‚â∫',
                     prcue: '‚âº',
                     precapprox: '‚™∑',
                     prec: '‚â∫',
                     preccurlyeq: '‚âº',
                     Precedes: '‚â∫',
                     PrecedesEqual: '‚™Ø',
                     PrecedesSlantEqual: '‚âº',
                     PrecedesTilde: '‚âæ',
                     preceq: '‚™Ø',
                     precnapprox: '‚™π',
                     precneqq: '‚™µ',
                     precnsim: '‚ã®',
                     pre: '‚™Ø',
                     prE: '‚™≥',
                     precsim: '‚âæ',
                     prime: '‚Ä≤',
                     Prime: '‚Ä≥',
                     primes: '‚Ñô',
                     prnap: '‚™π',
                     prnE: '‚™µ',
                     prnsim: '‚ã®',
                     prod: '‚àè',
                     Product: '‚àè',
                     profalar: '‚åÆ',
                     profline: '‚åí',
                     profsurf: '‚åì',
                     prop: '‚àù',
                     Proportional: '‚àù',
                     Proportion: '‚à∑',
                     propto: '‚àù',
                     prsim: '‚âæ',
                     prurel: '‚ä∞',
                     Pscr: 'ùí´',
                     pscr: 'ùìÖ',
                     Psi: 'Œ®',
                     psi: 'œà',
                     puncsp: '‚Äà',
                     Qfr: 'ùîî',
                     qfr: 'ùîÆ',
                     qint: '‚®å',
                     qopf: 'ùï¢',
                     Qopf: '‚Ñö',
                     qprime: '‚Åó',
                     Qscr: 'ùí¨',
                     qscr: 'ùìÜ',
                     quaternions: '‚Ñç',
                     quatint: '‚®ñ',
                     quest: '?',
                     questeq: '‚âü',
                     quot: '"',
                     QUOT: '"',
                     rAarr: '‚áõ',
                     race: '‚àΩ',
                     Racute: '≈î',
                     racute: '≈ï',
                     radic: '‚àö',
                     raemptyv: '‚¶≥',
                     rang: '‚ü©',
                     Rang: '‚ü´',
                     rangd: '‚¶í',
                     range: '‚¶•',
                     rangle: '‚ü©',
                     raquo: '¬ª',
                     rarrap: '‚•µ',
                     rarrb: '‚á•',
                     rarrbfs: '‚§†',
                     rarrc: '‚§≥',
                     rarr: '‚Üí',
                     Rarr: '‚Ü†',
                     rArr: '‚áí',
                     rarrfs: '‚§û',
                     rarrhk: '‚Ü™',
                     rarrlp: '‚Ü¨',
                     rarrpl: '‚•Ö',
                     rarrsim: '‚•¥',
                     Rarrtl: '‚§ñ',
                     rarrtl: '‚Ü£',
                     rarrw: '‚Üù',
                     ratail: '‚§ö',
                     rAtail: '‚§ú',
                     ratio: '‚à∂',
                     rationals: '‚Ñö',
                     rbarr: '‚§ç',
                     rBarr: '‚§è',
                     RBarr: '‚§ê',
                     rbbrk: '‚ù≥',
                     rbrace: '}',
                     rbrack: ']',
                     rbrke: '‚¶å',
                     rbrksld: '‚¶é',
                     rbrkslu: '‚¶ê',
                     Rcaron: '≈ò',
                     rcaron: '≈ô',
                     Rcedil: '≈ñ',
                     rcedil: '≈ó',
                     rceil: '‚åâ',
                     rcub: '}',
                     Rcy: '–†',
                     rcy: '—Ä',
                     rdca: '‚§∑',
                     rdldhar: '‚•©',
                     rdquo: '‚Äù',
                     rdquor: '‚Äù',
                     rdsh: '‚Ü≥',
                     real: '‚Ñú',
                     realine: '‚Ñõ',
                     realpart: '‚Ñú',
                     reals: '‚Ñù',
                     Re: '‚Ñú',
                     rect: '‚ñ≠',
                     reg: '¬Æ',
                     REG: '¬Æ',
                     ReverseElement: '‚àã',
                     ReverseEquilibrium: '‚áã',
                     ReverseUpEquilibrium: '‚•Ø',
                     rfisht: '‚•Ω',
                     rfloor: '‚åã',
                     rfr: 'ùîØ',
                     Rfr: '‚Ñú',
                     rHar: '‚•§',
                     rhard: '‚áÅ',
                     rharu: '‚áÄ',
                     rharul: '‚•¨',
                     Rho: 'Œ°',
                     rho: 'œÅ',
                     rhov: 'œ±',
                     RightAngleBracket: '‚ü©',
                     RightArrowBar: '‚á•',
                     rightarrow: '‚Üí',
                     RightArrow: '‚Üí',
                     Rightarrow: '‚áí',
                     RightArrowLeftArrow: '‚áÑ',
                     rightarrowtail: '‚Ü£',
                     RightCeiling: '‚åâ',
                     RightDoubleBracket: '‚üß',
                     RightDownTeeVector: '‚•ù',
                     RightDownVectorBar: '‚•ï',
                     RightDownVector: '‚áÇ',
                     RightFloor: '‚åã',
                     rightharpoondown: '‚áÅ',
                     rightharpoonup: '‚áÄ',
                     rightleftarrows: '‚áÑ',
                     rightleftharpoons: '‚áå',
                     rightrightarrows: '‚áâ',
                     rightsquigarrow: '‚Üù',
                     RightTeeArrow: '‚Ü¶',
                     RightTee: '‚ä¢',
                     RightTeeVector: '‚•õ',
                     rightthreetimes: '‚ãå',
                     RightTriangleBar: '‚ßê',
                     RightTriangle: '‚ä≥',
                     RightTriangleEqual: '‚äµ',
                     RightUpDownVector: '‚•è',
                     RightUpTeeVector: '‚•ú',
                     RightUpVectorBar: '‚•î',
                     RightUpVector: '‚Üæ',
                     RightVectorBar: '‚•ì',
                     RightVector: '‚áÄ',
                     ring: 'Àö',
                     risingdotseq: '‚âì',
                     rlarr: '‚áÑ',
                     rlhar: '‚áå',
                     rlm: '‚Äè',
                     rmoustache: '‚é±',
                     rmoust: '‚é±',
                     rnmid: '‚´Æ',
                     roang: '‚ü≠',
                     roarr: '‚áæ',
                     robrk: '‚üß',
                     ropar: '‚¶Ü',
                     ropf: 'ùï£',
                     Ropf: '‚Ñù',
                     roplus: '‚®Æ',
                     rotimes: '‚®µ',
                     RoundImplies: '‚•∞',
                     rpar: ')',
                     rpargt: '‚¶î',
                     rppolint: '‚®í',
                     rrarr: '‚áâ',
                     Rrightarrow: '‚áõ',
                     rsaquo: '‚Ä∫',
                     rscr: 'ùìá',
                     Rscr: '‚Ñõ',
                     rsh: '‚Ü±',
                     Rsh: '‚Ü±',
                     rsqb: ']',
                     rsquo: '‚Äô',
                     rsquor: '‚Äô',
                     rthree: '‚ãå',
                     rtimes: '‚ãä',
                     rtri: '‚ñπ',
                     rtrie: '‚äµ',
                     rtrif: '‚ñ∏',
                     rtriltri: '‚ßé',
                     RuleDelayed: '‚ß¥',
                     ruluhar: '‚•®',
                     rx: '‚Ñû',
                     Sacute: '≈ö',
                     sacute: '≈õ',
                     sbquo: '‚Äö',
                     scap: '‚™∏',
                     Scaron: '≈†',
                     scaron: '≈°',
                     Sc: '‚™º',
                     sc: '‚âª',
                     sccue: '‚âΩ',
                     sce: '‚™∞',
                     scE: '‚™¥',
                     Scedil: '≈û',
                     scedil: '≈ü',
                     Scirc: '≈ú',
                     scirc: '≈ù',
                     scnap: '‚™∫',
                     scnE: '‚™∂',
                     scnsim: '‚ã©',
                     scpolint: '‚®ì',
                     scsim: '‚âø',
                     Scy: '–°',
                     scy: '—Å',
                     sdotb: '‚ä°',
                     sdot: '‚ãÖ',
                     sdote: '‚©¶',
                     searhk: '‚§•',
                     searr: '‚Üò',
                     seArr: '‚áò',
                     searrow: '‚Üò',
                     sect: '¬ß',
                     semi: ';',
                     seswar: '‚§©',
                     setminus: '‚àñ',
                     setmn: '‚àñ',
                     sext: '‚ú∂',
                     Sfr: 'ùîñ',
                     sfr: 'ùî∞',
                     sfrown: '‚å¢',
                     sharp: '‚ôØ',
                     SHCHcy: '–©',
                     shchcy: '—â',
                     SHcy: '–®',
                     shcy: '—à',
                     ShortDownArrow: '‚Üì',
                     ShortLeftArrow: '‚Üê',
                     shortmid: '‚à£',
                     shortparallel: '‚à•',
                     ShortRightArrow: '‚Üí',
                     ShortUpArrow: '‚Üë',
                     shy: '¬≠',
                     Sigma: 'Œ£',
                     sigma: 'œÉ',
                     sigmaf: 'œÇ',
                     sigmav: 'œÇ',
                     sim: '‚àº',
                     simdot: '‚©™',
                     sime: '‚âÉ',
                     simeq: '‚âÉ',
                     simg: '‚™û',
                     simgE: '‚™†',
                     siml: '‚™ù',
                     simlE: '‚™ü',
                     simne: '‚âÜ',
                     simplus: '‚®§',
                     simrarr: '‚•≤',
                     slarr: '‚Üê',
                     SmallCircle: '‚àò',
                     smallsetminus: '‚àñ',
                     smashp: '‚®≥',
                     smeparsl: '‚ß§',
                     smid: '‚à£',
                     smile: '‚å£',
                     smt: '‚™™',
                     smte: '‚™¨',
                     smtes: '‚™¨',
                     SOFTcy: '–¨',
                     softcy: '—å',
                     solbar: '‚åø',
                     solb: '‚ßÑ',
                     sol: '/',
                     Sopf: 'ùïä',
                     sopf: 'ùï§',
                     spades: '‚ô†',
                     spadesuit: '‚ô†',
                     spar: '‚à•',
                     sqcap: '‚äì',
                     sqcaps: '‚äì',
                     sqcup: '‚äî',
                     sqcups: '‚äî',
                     Sqrt: '‚àö',
                     sqsub: '‚äè',
                     sqsube: '‚äë',
                     sqsubset: '‚äè',
                     sqsubseteq: '‚äë',
                     sqsup: '‚äê',
                     sqsupe: '‚äí',
                     sqsupset: '‚äê',
                     sqsupseteq: '‚äí',
                     square: '‚ñ°',
                     Square: '‚ñ°',
                     SquareIntersection: '‚äì',
                     SquareSubset: '‚äè',
                     SquareSubsetEqual: '‚äë',
                     SquareSuperset: '‚äê',
                     SquareSupersetEqual: '‚äí',
                     SquareUnion: '‚äî',
                     squarf: '‚ñ™',
                     squ: '‚ñ°',
                     squf: '‚ñ™',
                     srarr: '‚Üí',
                     Sscr: 'ùíÆ',
                     sscr: 'ùìà',
                     ssetmn: '‚àñ',
                     ssmile: '‚å£',
                     sstarf: '‚ãÜ',
                     Star: '‚ãÜ',
                     star: '‚òÜ',
                     starf: '‚òÖ',
                     straightepsilon: 'œµ',
                     straightphi: 'œï',
                     strns: '¬Ø',
                     sub: '‚äÇ',
                     Sub: '‚ãê',
                     subdot: '‚™Ω',
                     subE: '‚´Ö',
                     sube: '‚äÜ',
                     subedot: '‚´É',
                     submult: '‚´Å',
                     subnE: '‚´ã',
                     subne: '‚ää',
                     subplus: '‚™ø',
                     subrarr: '‚•π',
                     subset: '‚äÇ',
                     Subset: '‚ãê',
                     subseteq: '‚äÜ',
                     subseteqq: '‚´Ö',
                     SubsetEqual: '‚äÜ',
                     subsetneq: '‚ää',
                     subsetneqq: '‚´ã',
                     subsim: '‚´á',
                     subsub: '‚´ï',
                     subsup: '‚´ì',
                     succapprox: '‚™∏',
                     succ: '‚âª',
                     succcurlyeq: '‚âΩ',
                     Succeeds: '‚âª',
                     SucceedsEqual: '‚™∞',
                     SucceedsSlantEqual: '‚âΩ',
                     SucceedsTilde: '‚âø',
                     succeq: '‚™∞',
                     succnapprox: '‚™∫',
                     succneqq: '‚™∂',
                     succnsim: '‚ã©',
                     succsim: '‚âø',
                     SuchThat: '‚àã',
                     sum: '‚àë',
                     Sum: '‚àë',
                     sung: '‚ô™',
                     sup1: '¬π',
                     sup2: '¬≤',
                     sup3: '¬≥',
                     sup: '‚äÉ',
                     Sup: '‚ãë',
                     supdot: '‚™æ',
                     supdsub: '‚´ò',
                     supE: '‚´Ü',
                     supe: '‚äá',
                     supedot: '‚´Ñ',
                     Superset: '‚äÉ',
                     SupersetEqual: '‚äá',
                     suphsol: '‚üâ',
                     suphsub: '‚´ó',
                     suplarr: '‚•ª',
                     supmult: '‚´Ç',
                     supnE: '‚´å',
                     supne: '‚äã',
                     supplus: '‚´Ä',
                     supset: '‚äÉ',
                     Supset: '‚ãë',
                     supseteq: '‚äá',
                     supseteqq: '‚´Ü',
                     supsetneq: '‚äã',
                     supsetneqq: '‚´å',
                     supsim: '‚´à',
                     supsub: '‚´î',
                     supsup: '‚´ñ',
                     swarhk: '‚§¶',
                     swarr: '‚Üô',
                     swArr: '‚áô',
                     swarrow: '‚Üô',
                     swnwar: '‚§™',
                     szlig: '√ü',
                     Tab: '	',
                     target: '‚åñ',
                     Tau: 'Œ§',
                     tau: 'œÑ',
                     tbrk: '‚é¥',
                     Tcaron: '≈§',
                     tcaron: '≈•',
                     Tcedil: '≈¢',
                     tcedil: '≈£',
                     Tcy: '–¢',
                     tcy: '—Ç',
                     tdot: '‚Éõ',
                     telrec: '‚åï',
                     Tfr: 'ùîó',
                     tfr: 'ùî±',
                     there4: '‚à¥',
                     therefore: '‚à¥',
                     Therefore: '‚à¥',
                     Theta: 'Œò',
                     theta: 'Œ∏',
                     thetasym: 'œë',
                     thetav: 'œë',
                     thickapprox: '‚âà',
                     thicksim: '‚àº',
                     ThickSpace: '‚Åü',
                     ThinSpace: '‚Äâ',
                     thinsp: '‚Äâ',
                     thkap: '‚âà',
                     thksim: '‚àº',
                     THORN: '√û',
                     thorn: '√æ',
                     tilde: 'Àú',
                     Tilde: '‚àº',
                     TildeEqual: '‚âÉ',
                     TildeFullEqual: '‚âÖ',
                     TildeTilde: '‚âà',
                     timesbar: '‚®±',
                     timesb: '‚ä†',
                     times: '√ó',
                     timesd: '‚®∞',
                     tint: '‚à≠',
                     toea: '‚§®',
                     topbot: '‚å∂',
                     topcir: '‚´±',
                     top: '‚ä§',
                     Topf: 'ùïã',
                     topf: 'ùï•',
                     topfork: '‚´ö',
                     tosa: '‚§©',
                     tprime: '‚Ä¥',
                     trade: '‚Ñ¢',
                     TRADE: '‚Ñ¢',
                     triangle: '‚ñµ',
                     triangledown: '‚ñø',
                     triangleleft: '‚óÉ',
                     trianglelefteq: '‚ä¥',
                     triangleq: '‚âú',
                     triangleright: '‚ñπ',
                     trianglerighteq: '‚äµ',
                     tridot: '‚ó¨',
                     trie: '‚âú',
                     triminus: '‚®∫',
                     TripleDot: '‚Éõ',
                     triplus: '‚®π',
                     trisb: '‚ßç',
                     tritime: '‚®ª',
                     trpezium: '‚è¢',
                     Tscr: 'ùíØ',
                     tscr: 'ùìâ',
                     TScy: '–¶',
                     tscy: '—Ü',
                     TSHcy: '–ã',
                     tshcy: '—õ',
                     Tstrok: '≈¶',
                     tstrok: '≈ß',
                     twixt: '‚â¨',
                     twoheadleftarrow: '‚Üû',
                     twoheadrightarrow: '‚Ü†',
                     Uacute: '√ö',
                     uacute: '√∫',
                     uarr: '‚Üë',
                     Uarr: '‚Üü',
                     uArr: '‚áë',
                     Uarrocir: '‚•â',
                     Ubrcy: '–é',
                     ubrcy: '—û',
                     Ubreve: '≈¨',
                     ubreve: '≈≠',
                     Ucirc: '√õ',
                     ucirc: '√ª',
                     Ucy: '–£',
                     ucy: '—É',
                     udarr: '‚áÖ',
                     Udblac: '≈∞',
                     udblac: '≈±',
                     udhar: '‚•Æ',
                     ufisht: '‚•æ',
                     Ufr: 'ùîò',
                     ufr: 'ùî≤',
                     Ugrave: '√ô',
                     ugrave: '√π',
                     uHar: '‚•£',
                     uharl: '‚Üø',
                     uharr: '‚Üæ',
                     uhblk: '‚ñÄ',
                     ulcorn: '‚åú',
                     ulcorner: '‚åú',
                     ulcrop: '‚åè',
                     ultri: '‚ó∏',
                     Umacr: '≈™',
                     umacr: '≈´',
                     uml: '¬®',
                     UnderBar: '_',
                     UnderBrace: '‚èü',
                     UnderBracket: '‚éµ',
                     UnderParenthesis: '‚èù',
                     Union: '‚ãÉ',
                     UnionPlus: '‚äé',
                     Uogon: '≈≤',
                     uogon: '≈≥',
                     Uopf: 'ùïå',
                     uopf: 'ùï¶',
                     UpArrowBar: '‚§í',
                     uparrow: '‚Üë',
                     UpArrow: '‚Üë',
                     Uparrow: '‚áë',
                     UpArrowDownArrow: '‚áÖ',
                     updownarrow: '‚Üï',
                     UpDownArrow: '‚Üï',
                     Updownarrow: '‚áï',
                     UpEquilibrium: '‚•Æ',
                     upharpoonleft: '‚Üø',
                     upharpoonright: '‚Üæ',
                     uplus: '‚äé',
                     UpperLeftArrow: '‚Üñ',
                     UpperRightArrow: '‚Üó',
                     upsi: 'œÖ',
                     Upsi: 'œí',
                     upsih: 'œí',
                     Upsilon: 'Œ•',
                     upsilon: 'œÖ',
                     UpTeeArrow: '‚Ü•',
                     UpTee: '‚ä•',
                     upuparrows: '‚áà',
                     urcorn: '‚åù',
                     urcorner: '‚åù',
                     urcrop: '‚åé',
                     Uring: '≈Æ',
                     uring: '≈Ø',
                     urtri: '‚óπ',
                     Uscr: 'ùí∞',
                     uscr: 'ùìä',
                     utdot: '‚ã∞',
                     Utilde: '≈®',
                     utilde: '≈©',
                     utri: '‚ñµ',
                     utrif: '‚ñ¥',
                     uuarr: '‚áà',
                     Uuml: '√ú',
                     uuml: '√º',
                     uwangle: '‚¶ß',
                     vangrt: '‚¶ú',
                     varepsilon: 'œµ',
                     varkappa: 'œ∞',
                     varnothing: '‚àÖ',
                     varphi: 'œï',
                     varpi: 'œñ',
                     varpropto: '‚àù',
                     varr: '‚Üï',
                     vArr: '‚áï',
                     varrho: 'œ±',
                     varsigma: 'œÇ',
                     varsubsetneq: '‚ää',
                     varsubsetneqq: '‚´ã',
                     varsupsetneq: '‚äã',
                     varsupsetneqq: '‚´å',
                     vartheta: 'œë',
                     vartriangleleft: '‚ä≤',
                     vartriangleright: '‚ä≥',
                     vBar: '‚´®',
                     Vbar: '‚´´',
                     vBarv: '‚´©',
                     Vcy: '–í',
                     vcy: '–≤',
                     vdash: '‚ä¢',
                     vDash: '‚ä®',
                     Vdash: '‚ä©',
                     VDash: '‚ä´',
                     Vdashl: '‚´¶',
                     veebar: '‚äª',
                     vee: '‚à®',
                     Vee: '‚ãÅ',
                     veeeq: '‚âö',
                     vellip: '‚ãÆ',
                     verbar: '|',
                     Verbar: '‚Äñ',
                     vert: '|',
                     Vert: '‚Äñ',
                     VerticalBar: '‚à£',
                     VerticalLine: '|',
                     VerticalSeparator: '‚ùò',
                     VerticalTilde: '‚âÄ',
                     VeryThinSpace: '‚Ää',
                     Vfr: 'ùîô',
                     vfr: 'ùî≥',
                     vltri: '‚ä≤',
                     vnsub: '‚äÇ',
                     vnsup: '‚äÉ',
                     Vopf: 'ùïç',
                     vopf: 'ùïß',
                     vprop: '‚àù',
                     vrtri: '‚ä≥',
                     Vscr: 'ùí±',
                     vscr: 'ùìã',
                     vsubnE: '‚´ã',
                     vsubne: '‚ää',
                     vsupnE: '‚´å',
                     vsupne: '‚äã',
                     Vvdash: '‚ä™',
                     vzigzag: '‚¶ö',
                     Wcirc: '≈¥',
                     wcirc: '≈µ',
                     wedbar: '‚©ü',
                     wedge: '‚àß',
                     Wedge: '‚ãÄ',
                     wedgeq: '‚âô',
                     weierp: '‚Ñò',
                     Wfr: 'ùîö',
                     wfr: 'ùî¥',
                     Wopf: 'ùïé',
                     wopf: 'ùï®',
                     wp: '‚Ñò',
                     wr: '‚âÄ',
                     wreath: '‚âÄ',
                     Wscr: 'ùí≤',
                     wscr: 'ùìå',
                     xcap: '‚ãÇ',
                     xcirc: '‚óØ',
                     xcup: '‚ãÉ',
                     xdtri: '‚ñΩ',
                     Xfr: 'ùîõ',
                     xfr: 'ùîµ',
                     xharr: '‚ü∑',
                     xhArr: '‚ü∫',
                     Xi: 'Œû',
                     xi: 'Œæ',
                     xlarr: '‚üµ',
                     xlArr: '‚ü∏',
                     xmap: '‚üº',
                     xnis: '‚ãª',
                     xodot: '‚®Ä',
                     Xopf: 'ùïè',
                     xopf: 'ùï©',
                     xoplus: '‚®Å',
                     xotime: '‚®Ç',
                     xrarr: '‚ü∂',
                     xrArr: '‚üπ',
                     Xscr: 'ùí≥',
                     xscr: 'ùìç',
                     xsqcup: '‚®Ü',
                     xuplus: '‚®Ñ',
                     xutri: '‚ñ≥',
                     xvee: '‚ãÅ',
                     xwedge: '‚ãÄ',
                     Yacute: '√ù',
                     yacute: '√Ω',
                     YAcy: '–Ø',
                     yacy: '—è',
                     Ycirc: '≈∂',
                     ycirc: '≈∑',
                     Ycy: '–´',
                     ycy: '—ã',
                     yen: '¬•',
                     Yfr: 'ùîú',
                     yfr: 'ùî∂',
                     YIcy: '–á',
                     yicy: '—ó',
                     Yopf: 'ùïê',
                     yopf: 'ùï™',
                     Yscr: 'ùí¥',
                     yscr: 'ùìé',
                     YUcy: '–Æ',
                     yucy: '—é',
                     yuml: '√ø',
                     Yuml: '≈∏',
                     Zacute: '≈π',
                     zacute: '≈∫',
                     Zcaron: '≈Ω',
                     zcaron: '≈æ',
                     Zcy: '–ó',
                     zcy: '–∑',
                     Zdot: '≈ª',
                     zdot: '≈º',
                     zeetrf: '‚Ñ®',
                     ZeroWidthSpace: '‚Äã',
                     Zeta: 'Œñ',
                     zeta: 'Œ∂',
                     zfr: 'ùî∑',
                     Zfr: '‚Ñ®',
                     ZHcy: '–ñ',
                     zhcy: '–∂',
                     zigrarr: '‚áù',
                     zopf: 'ùï´',
                     Zopf: '‚Ñ§',
                     Zscr: 'ùíµ',
                     zscr: 'ùìè',
                     zwj: '‚Äç',
                     zwnj: '‚Äå' };

    // Constants for character codes:

    var C_NEWLINE = 10;
    var C_SPACE = 32;
    var C_ASTERISK = 42;
    var C_UNDERSCORE = 95;
    var C_BACKTICK = 96;
    var C_OPEN_BRACKET = 91;
    var C_CLOSE_BRACKET = 93;
    var C_LESSTHAN = 60;
    var C_GREATERTHAN = 62;
    var C_BANG = 33;
    var C_BACKSLASH = 92;
    var C_AMPERSAND = 38;
    var C_OPEN_PAREN = 40;
    var C_COLON = 58;

    // Some regexps used in inline parser:

    var ESCAPABLE = '[!"#$%&\'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]';
    var ESCAPED_CHAR = '\\\\' + ESCAPABLE;
    var IN_DOUBLE_QUOTES = '"(' + ESCAPED_CHAR + '|[^"\\x00])*"';
    var IN_SINGLE_QUOTES = '\'(' + ESCAPED_CHAR + '|[^\'\\x00])*\'';
    var IN_PARENS = '\\((' + ESCAPED_CHAR + '|[^)\\x00])*\\)';
    var REG_CHAR = '[^\\\\()\\x00-\\x20]';
    var IN_PARENS_NOSP = '\\((' + REG_CHAR + '|' + ESCAPED_CHAR + ')*\\)';
    var TAGNAME = '[A-Za-z][A-Za-z0-9]*';
    var BLOCKTAGNAME = '(?:article|header|aside|hgroup|iframe|blockquote|hr|body|li|map|button|object|canvas|ol|caption|output|col|p|colgroup|pre|dd|progress|div|section|dl|table|td|dt|tbody|embed|textarea|fieldset|tfoot|figcaption|th|figure|thead|footer|footer|tr|form|ul|h1|h2|h3|h4|h5|h6|video|script|style)';
    var ATTRIBUTENAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
    var UNQUOTEDVALUE = "[^\"'=<>`\\x00-\\x20]+";
    var SINGLEQUOTEDVALUE = "'[^']*'";
    var DOUBLEQUOTEDVALUE = '"[^"]*"';
    var ATTRIBUTEVALUE = "(?:" + UNQUOTEDVALUE + "|" + SINGLEQUOTEDVALUE + "|" + DOUBLEQUOTEDVALUE + ")";
    var ATTRIBUTEVALUESPEC = "(?:" + "\\s*=" + "\\s*" + ATTRIBUTEVALUE + ")";
    var ATTRIBUTE = "(?:" + "\\s+" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + "?)";
    var OPENTAG = "<" + TAGNAME + ATTRIBUTE + "*" + "\\s*/?>";
    var CLOSETAG = "</" + TAGNAME + "\\s*[>]";
    var OPENBLOCKTAG = "<" + BLOCKTAGNAME + ATTRIBUTE + "*" + "\\s*/?>";
    var CLOSEBLOCKTAG = "</" + BLOCKTAGNAME + "\\s*[>]";
    var HTMLCOMMENT = "<!--([^-]+|[-][^-]+)*-->";
    var PROCESSINGINSTRUCTION = "[<][?].*?[?][>]";
    var DECLARATION = "<![A-Z]+" + "\\s+[^>]*>";
    var CDATA = "<!\\[CDATA\\[([^\\]]+|\\][^\\]]|\\]\\][^>])*\\]\\]>";
    var HTMLTAG = "(?:" + OPENTAG + "|" + CLOSETAG + "|" + HTMLCOMMENT + "|" +
            PROCESSINGINSTRUCTION + "|" + DECLARATION + "|" + CDATA + ")";
    var HTMLBLOCKOPEN = "<(?:" + BLOCKTAGNAME + "[\\s/>]" + "|" +
            "/" + BLOCKTAGNAME + "[\\s>]" + "|" + "[?!])";
    var ENTITY = "&(?:#x[a-f0-9]{1,8}|#[0-9]{1,8}|[a-z][a-z0-9]{1,31});";

    var reHtmlTag = new RegExp('^' + HTMLTAG, 'i');

    var reHtmlBlockOpen = new RegExp('^' + HTMLBLOCKOPEN, 'i');

    var reLinkTitle = new RegExp(
        '^(?:"(' + ESCAPED_CHAR + '|[^"\\x00])*"' +
            '|' +
            '\'(' + ESCAPED_CHAR + '|[^\'\\x00])*\'' +
            '|' +
            '\\((' + ESCAPED_CHAR + '|[^)\\x00])*\\))');

    var reLinkDestinationBraces = new RegExp(
        '^(?:[<](?:[^<>\\n\\\\\\x00]' + '|' + ESCAPED_CHAR + '|' + '\\\\)*[>])');

    var reLinkDestination = new RegExp(
        '^(?:' + REG_CHAR + '+|' + ESCAPED_CHAR + '|' + IN_PARENS_NOSP + ')*');

    var reEscapable = new RegExp(ESCAPABLE);

    var reAllEscapedChar = new RegExp('\\\\(' + ESCAPABLE + ')', 'g');

    var reEscapedChar = new RegExp('^\\\\(' + ESCAPABLE + ')');

    var reAllTab = /\t/g;

    var reHrule = /^(?:(?:\* *){3,}|(?:_ *){3,}|(?:- *){3,}) *$/;

    var reEntityHere = new RegExp('^' + ENTITY, 'i');

    var reEntity = new RegExp(ENTITY, 'gi');

    // Matches a character with a special meaning in markdown,
    // or a string of non-special characters.  Note:  we match
    // clumps of _ or * or `, because they need to be handled in groups.
    var reMain = /^(?:[_*`\n]+|[\[\]\\!<&*_]|(?: *[^\n `\[\]\\!<&*_]+)+|[ \n]+)/m;

    // UTILITY FUNCTIONS
    // polyfill for fromCodePoint:
    // https://github.com/mathiasbynens/String.fromCodePoint
    /*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
    if (!String.fromCodePoint) {
        (function() {
            var defineProperty = (function() {
                // IE 8 only supports `Object.defineProperty` on DOM elements
                try {
                    var object = {};
                    var $defineProperty = Object.defineProperty;
                    var result = $defineProperty(object, object, object) && $defineProperty;
                } catch(error) {}
                return result;
            }());
            var stringFromCharCode = String.fromCharCode;
            var floor = Math.floor;
            var fromCodePoint = function(_) {
                var MAX_SIZE = 0x4000;
                var codeUnits = [];
                var highSurrogate;
                var lowSurrogate;
                var index = -1;
                var length = arguments.length;
                if (!length) {
                    return '';
                }
                var result = '';
                while (++index < length) {
                    var codePoint = Number(arguments[index]);
                    if (
                        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                            codePoint < 0 || // not a valid Unicode code point
                            codePoint > 0x10FFFF || // not a valid Unicode code point
                            floor(codePoint) != codePoint // not an integer
                    ) {
                        return String.fromCharCode(0xFFFD);
                    }
                    if (codePoint <= 0xFFFF) { // BMP code point
                        codeUnits.push(codePoint);
                    } else { // Astral code point; split in surrogate halves
                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                        codePoint -= 0x10000;
                        highSurrogate = (codePoint >> 10) + 0xD800;
                        lowSurrogate = (codePoint % 0x400) + 0xDC00;
                        codeUnits.push(highSurrogate, lowSurrogate);
                    }
                    if (index + 1 == length || codeUnits.length > MAX_SIZE) {
                        result += stringFromCharCode.apply(null, codeUnits);
                        codeUnits.length = 0;
                    }
                }
                return result;
            };
            if (defineProperty) {
                defineProperty(String, 'fromCodePoint', {
                    'value': fromCodePoint,
                    'configurable': true,
                    'writable': true
                });
            } else {
                String.fromCodePoint = fromCodePoint;
            }
        }());
    }

    var entityToChar = function(m) {
        var isNumeric = /^&#/.test(m);
        var isHex = /^&#[Xx]/.test(m);
        var uchar;
        if (isNumeric) {
            var num;
            if (isHex) {
                num = parseInt(m.slice(3,-1), 16);
            } else {
                num = parseInt(m.slice(2,-1), 10);
            }
            uchar = String.fromCodePoint(num);
        } else {
            uchar = entities[m.slice(1,-1)];
        }
        return (uchar || m);
    };

    // Replace entities and backslash escapes with literal characters.
    var unescapeEntBS = function(s) {
        return s.replace(reAllEscapedChar, '$1')
                .replace(reEntity, entityToChar);
    };

    // Returns true if string contains only space characters.
    var isBlank = function(s) {
        return /^\s*$/.test(s);
    };

    // Normalize reference label: collapse internal whitespace
    // to single space, remove leading/trailing whitespace, case fold.
    var normalizeReference = function(s) {
        return s.trim()
            .replace(/\s+/,' ')
            .toUpperCase();
    };

    // Attempt to match a regex in string s at offset offset.
    // Return index of match or null.
    var matchAt = function(re, s, offset) {
        var res = s.slice(offset).match(re);
        if (res) {
            return offset + res.index;
        } else {
            return null;
        }
    };

    // Convert tabs to spaces on each line using a 4-space tab stop.
    var detabLine = function(text) {
        if (text.indexOf('\t') == -1) {
            return text;
        } else {
            var lastStop = 0;
            return text.replace(reAllTab, function(match, offset) {
                var result = '    '.slice((offset - lastStop) % 4);
                lastStop = offset + 1;
                return result;
            });
        }
    };

    // INLINE PARSER

    // These are methods of an InlineParser object, defined below.
    // An InlineParser keeps track of a subject (a string to be
    // parsed) and a position in that subject.

    // If re matches at current position in the subject, advance
    // position in subject and return the match; otherwise return null.
    var match = function(re) {
        var match = re.exec(this.subject.slice(this.pos));
        if (match) {
            this.pos += match.index + match[0].length;
            return match[0];
        } else {
            return null;
        }
    };

    // Returns the code for the character at the current subject position, or -1
    // there are no more characters.
    var peek = function() {
        if (this.pos < this.subject.length) {
            return this.subject.charCodeAt(this.pos);
        } else {
            return -1;
        }
    };

    // Parse zero or more space characters, including at most one newline
    var spnl = function() {
        this.match(/^ *(?:\n *)?/);
        return 1;
    };

    // All of the parsers below try to match something at the current position
    // in the subject.  If they succeed in matching anything, they
    // return the inline matched, advancing the subject.

    // Attempt to parse backticks, returning either a backtick code span or a
    // literal sequence of backticks.
    var parseBackticks = function(inlines) {
        var startpos = this.pos;
        var ticks = this.match(/^`+/);
        if (!ticks) {
            return 0;
        }
        var afterOpenTicks = this.pos;
        var foundCode = false;
        var match;
        while (!foundCode && (match = this.match(/`+/m))) {
            if (match == ticks) {
                inlines.push({ t: 'Code', c: this.subject.slice(afterOpenTicks,
                                                          this.pos - ticks.length)
                         .replace(/[ \n]+/g,' ')
                          .trim() });
                return true;
            }
        }
        // If we got here, we didn't match a closing backtick sequence.
        this.pos = afterOpenTicks;
        inlines.push({ t: 'Str', c: ticks });
        return true;
    };

    // Parse a backslash-escaped special character, adding either the escaped
    // character, a hard line break (if the backslash is followed by a newline),
    // or a literal backslash to the 'inlines' list.
    var parseBackslash = function(inlines) {
        var subj = this.subject,
            pos  = this.pos;
        if (subj.charCodeAt(pos) === C_BACKSLASH) {
            if (subj.charAt(pos + 1) === '\n') {
                this.pos = this.pos + 2;
                inlines.push({ t: 'Hardbreak' });
            } else if (reEscapable.test(subj.charAt(pos + 1))) {
                this.pos = this.pos + 2;
                inlines.push({ t: 'Str', c: subj.charAt(pos + 1) });
            } else {
                this.pos++;
                inlines.push({t: 'Str', c: '\\'});
            }
            return true;
        } else {
            return false;
        }
    };

    // Attempt to parse an autolink (URL or email in pointy brackets).
    var parseAutolink = function(inlines) {
        var m;
        var dest;
        if ((m = this.match(/^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/))) {  // email autolink
            dest = m.slice(1,-1);
            inlines.push(
                    {t: 'Link',
                     label: [{ t: 'Str', c: dest }],
                     destination: 'mailto:' + encodeURI(unescape(dest)) });
            return true;
        } else if ((m = this.match(/^<(?:coap|doi|javascript|aaa|aaas|about|acap|cap|cid|crid|data|dav|dict|dns|file|ftp|geo|go|gopher|h323|http|https|iax|icap|im|imap|info|ipp|iris|iris.beep|iris.xpc|iris.xpcs|iris.lwz|ldap|mailto|mid|msrp|msrps|mtqp|mupdate|news|nfs|ni|nih|nntp|opaquelocktoken|pop|pres|rtsp|service|session|shttp|sieve|sip|sips|sms|snmp|soap.beep|soap.beeps|tag|tel|telnet|tftp|thismessage|tn3270|tip|tv|urn|vemmi|ws|wss|xcon|xcon-userid|xmlrpc.beep|xmlrpc.beeps|xmpp|z39.50r|z39.50s|adiumxtra|afp|afs|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|chrome|chrome-extension|com-eventbrite-attendee|content|cvs|dlna-playsingle|dlna-playcontainer|dtn|dvb|ed2k|facetime|feed|finger|fish|gg|git|gizmoproject|gtalk|hcp|icon|ipn|irc|irc6|ircs|itms|jar|jms|keyparc|lastfm|ldaps|magnet|maps|market|message|mms|ms-help|msnim|mumble|mvn|notes|oid|palm|paparazzi|platform|proxy|psyc|query|res|resource|rmi|rsync|rtmp|secondlife|sftp|sgn|skype|smb|soldat|spotify|ssh|steam|svn|teamspeak|things|udp|unreal|ut2004|ventrilo|view-source|webcal|wtai|wyciwyg|xfire|xri|ymsgr):[^<>\x00-\x20]*>/i))) {
            dest = m.slice(1,-1);
            inlines.push({
                      t: 'Link',
                      label: [{ t: 'Str', c: dest }],
                      destination: encodeURI(unescape(dest)) });
            return true;
        } else {
            return false;
        }
    };

    // Attempt to parse a raw HTML tag.
    var parseHtmlTag = function(inlines) {
        var m = this.match(reHtmlTag);
        if (m) {
            inlines.push({ t: 'Html', c: m });
            return true;
        } else {
            return false;
        }
    };

    // Scan a sequence of characters with code cc, and return information about
    // the number of delimiters and whether they are positioned such that
    // they can open and/or close emphasis or strong emphasis.  A utility
    // function for strong/emph parsing.
    var scanDelims = function(cc) {
        var numdelims = 0;
        var first_close_delims = 0;
        var char_before, char_after, cc_after;
        var startpos = this.pos;

        char_before = this.pos === 0 ? '\n' :
            this.subject.charAt(this.pos - 1);

        while (this.peek() === cc) {
            numdelims++;
            this.pos++;
        }

        cc_after = this.peek();
        if (cc_after === -1) {
            char_after = '\n';
        } else {
            char_after = String.fromCodePoint(cc_after);
        }

        var can_open = numdelims > 0 && numdelims <= 3 && !(/\s/.test(char_after));
        var can_close = numdelims > 0 && numdelims <= 3 && !(/\s/.test(char_before));
        if (cc === C_UNDERSCORE) {
            can_open = can_open && !((/[a-z0-9]/i).test(char_before));
            can_close = can_close && !((/[a-z0-9]/i).test(char_after));
        }
        this.pos = startpos;
        return { numdelims: numdelims,
                 can_open: can_open,
                 can_close: can_close };
    };

    var Emph = function(ils) {
        return {t: 'Emph', c: ils};
    };

    var Strong = function(ils) {
        return {t: 'Strong', c: ils};
    };

    var Str = function(s) {
        return {t: 'Str', c: s};
    };

    // Attempt to parse emphasis or strong emphasis.
    var parseEmphasis = function(cc,inlines) {
        var startpos = this.pos;
        var c ;
        var first_close = 0;
        c = String.fromCodePoint(cc);

        var numdelims;
        var numclosedelims;
        var delimpos;

        // Get opening delimiters.
        res = this.scanDelims(cc);
        numdelims = res.numdelims;

        if (numdelims === 0) {
            this.pos = startpos;
            return false;
        }

        if (numdelims >= 4 || !res.can_open) {
            this.pos += numdelims;
            inlines.push(Str(this.subject.slice(startpos, startpos + numdelims)));
            return true;
        }

        this.pos += numdelims;

        var delims_to_match = numdelims;

        var current = [];
        var firstend;
        var firstpos;
        var state = 0;
        var can_close = false;
        var can_open = false;
        var last_emphasis_closer = null;
        while (this.last_emphasis_closer[c] >= this.pos) {
            res = this.scanDelims(cc);
            numclosedelims = res.numdelims;

            if (res.can_close) {
                if (last_emphasis_closer === null ||
                    last_emphasis_closer < this.pos) {
                    last_emphasis_closer = this.pos;
                }
                if (numclosedelims === 3 && delims_to_match === 3) {
                    delims_to_match -= 3;
                    this.pos += 3;
                    current = [{t: 'Strong', c: [{t: 'Emph', c: current}]}];
                } else if (numclosedelims >= 2 && delims_to_match >= 2) {
                    delims_to_match -= 2;
                    this.pos += 2;
                    firstend = current.length;
                    firstpos = this.pos;
                    current = [{t: 'Strong', c: current}];
                } else if (numclosedelims >= 1 && delims_to_match >= 1) {
                    delims_to_match -= 1;
                    this.pos += 1;
                    firstend = current.length;
                    firstpos = this.pos;
                    current = [{t: 'Emph', c: current}];
                } else {
                    if (!(this.parseInline(current,true))) {
                        break;
                    }
                }
                if (delims_to_match === 0) {
                    Array.prototype.push.apply(inlines, current);
                    return true;
                }
            } else if (!(this.parseInline(current,true))) {
                break;
            }
        }

        // we didn't match emphasis: fallback
        inlines.push(Str(this.subject.slice(startpos,
                                            startpos + delims_to_match)));
        if (delims_to_match < numdelims) {
            Array.prototype.push.apply(inlines, current.slice(0,firstend));
            this.pos = firstpos;
        } else { // delims_to_match === numdelims
            this.pos = startpos + delims_to_match;
        }

        if (last_emphasis_closer) {
            this.last_emphasis_closer[c] = last_emphasis_closer;
        }
        return true;
    };

    // Attempt to parse link title (sans quotes), returning the string
    // or null if no match.
    var parseLinkTitle = function() {
        var title = this.match(reLinkTitle);
        if (title) {
            // chop off quotes from title and unescape:
            return unescapeEntBS(title.substr(1, title.length - 2));
        } else {
            return null;
        }
    };

    // Attempt to parse link destination, returning the string or
    // null if no match.
    var parseLinkDestination = function() {
        var res = this.match(reLinkDestinationBraces);
        if (res) {  // chop off surrounding <..>:
            return encodeURI(unescape(unescapeEntBS(res.substr(1, res.length - 2))));
        } else {
            res = this.match(reLinkDestination);
            if (res !== null) {
                return encodeURI(unescape(unescapeEntBS(res)));
            } else {
                return null;
            }
        }
    };

    // Attempt to parse a link label, returning number of characters parsed.
    var parseLinkLabel = function() {
        if (this.peek() != C_OPEN_BRACKET) {
            return 0;
        }
        var startpos = this.pos;
        var nest_level = 0;
        if (this.label_nest_level > 0) {
            // If we've already checked to the end of this subject
            // for a label, even with a different starting [, we
            // know we won't find one here and we can just return.
            // This avoids lots of backtracking.
            // Note:  nest level 1 would be: [foo [bar]
            //        nest level 2 would be: [foo [bar [baz]
            this.label_nest_level--;
            return 0;
        }
        this.pos++;  // advance past [
        var c;
        while ((c = this.peek()) && c != -1 && (c != C_CLOSE_BRACKET || nest_level > 0)) {
            switch (c) {
            case C_BACKTICK:
                this.parseBackticks([]);
                break;
            case C_LESSTHAN:
                if (!(this.parseAutolink([]) || this.parseHtmlTag([]))) {
                    this.pos++;
                }
                break;
            case C_OPEN_BRACKET:  // nested []
                nest_level++;
                this.pos++;
                break;
            case C_CLOSE_BRACKET:  // nested []
                nest_level--;
                this.pos++;
                break;
            case C_BACKSLASH:
                this.parseBackslash([]);
                break;
            default:
                this.parseString([]);
            }
        }
        if (c === C_CLOSE_BRACKET) {
            this.label_nest_level = 0;
            this.pos++; // advance past ]
            return this.pos - startpos;
        } else {
            if (c === -1) {
                this.label_nest_level = nest_level;
            }
            this.pos = startpos;
            return 0;
        }
    };

    // Parse raw link label, including surrounding [], and return
    // inline contents.  (Note:  this is not a method of InlineParser.)
    var parseRawLabel = function(s) {
        // note:  parse without a refmap; we don't want links to resolve
        // in nested brackets!
        return new InlineParser().parse(s.substr(1, s.length - 2), {});
    };

    // Attempt to parse a link.  If successful, return the link.
    var parseLink = function(inlines) {
        var startpos = this.pos;
        var reflabel;
        var n;
        var dest;
        var title;

        n = this.parseLinkLabel();
        if (n === 0) {
            return false;
        }
        var afterlabel = this.pos;
        var rawlabel = this.subject.substr(startpos, n);

        // if we got this far, we've parsed a label.
        // Try to parse an explicit link: [label](url "title")
        if (this.peek() == C_OPEN_PAREN) {
            this.pos++;
            if (this.spnl() &&
                ((dest = this.parseLinkDestination()) !== null) &&
                this.spnl() &&
                // make sure there's a space before the title:
                (/^\s/.test(this.subject.charAt(this.pos - 1)) &&
                 (title = this.parseLinkTitle() || '') || true) &&
                this.spnl() &&
                this.match(/^\)/)) {
                inlines.push({ t: 'Link',
                          destination: dest,
                          title: title,
                          label: parseRawLabel(rawlabel) });
                return true;
            } else {
                this.pos = startpos;
                return false;
            }
        }
        // If we're here, it wasn't an explicit link. Try to parse a reference link.
        // first, see if there's another label
        var savepos = this.pos;
        this.spnl();
        var beforelabel = this.pos;
        n = this.parseLinkLabel();
        if (n == 2) {
            // empty second label
            reflabel = rawlabel;
        } else if (n > 0) {
            reflabel = this.subject.slice(beforelabel, beforelabel + n);
        } else {
            this.pos = savepos;
            reflabel = rawlabel;
        }
        // lookup rawlabel in refmap
        var link = this.refmap[normalizeReference(reflabel)];
        if (link) {
            inlines.push({t: 'Link',
                     destination: link.destination,
                     title: link.title,
                     label: parseRawLabel(rawlabel) });
            return true;
        } else {
            this.pos = startpos;
            return false;
        }
        // Nothing worked, rewind:
        this.pos = startpos;
        return false;
    };

    // Attempt to parse an entity, return Entity object if successful.
    var parseEntity = function(inlines) {
        var m;
        if ((m = this.match(reEntityHere))) {
            inlines.push({ t: 'Str', c: entityToChar(m) });
            return true;
        } else {
            return false;
        }
    };

    // Parse a run of ordinary characters, or a single character with
    // a special meaning in markdown, as a plain string, adding to inlines.
    var parseString = function(inlines) {
        var m;
        if ((m = this.match(reMain))) {
            inlines.push({ t: 'Str', c: m });
            return true;
        } else {
            return false;
        }
    };

    // Parse a newline.  If it was preceded by two spaces, return a hard
    // line break; otherwise a soft line break.
    var parseNewline = function(inlines) {
        var m = this.match(/^ *\n/);
        if (m) {
            if (m.length > 2) {
                inlines.push({ t: 'Hardbreak' });
            } else if (m.length > 0) {
                inlines.push({ t: 'Softbreak' });
            }
            return true;
        }
        return false;
    };

    // Attempt to parse an image.  If the opening '!' is not followed
    // by a link, return a literal '!'.
    var parseImage = function(inlines) {
        if (this.match(/^!/)) {
            var link = this.parseLink(inlines);
            if (link) {
                inlines[inlines.length - 1].t = 'Image';
                return true;
            } else {
                inlines.push({ t: 'Str', c: '!' });
                return true;
            }
        } else {
            return false;
        }
    };

    // Attempt to parse a link reference, modifying refmap.
    var parseReference = function(s, refmap) {
        this.subject = s;
        this.pos = 0;
        this.label_nest_level = 0;
        var rawlabel;
        var dest;
        var title;
        var matchChars;
        var startpos = this.pos;
        var match;

        // label:
        matchChars = this.parseLinkLabel();
        if (matchChars === 0) {
            return 0;
        } else {
            rawlabel = this.subject.substr(0, matchChars);
        }

        // colon:
        if (this.peek() === C_COLON) {
            this.pos++;
        } else {
            this.pos = startpos;
            return 0;
        }

        //  link url
        this.spnl();

        dest = this.parseLinkDestination();
        if (dest === null || dest.length === 0) {
            this.pos = startpos;
            return 0;
        }

        var beforetitle = this.pos;
        this.spnl();
        title = this.parseLinkTitle();
        if (title === null) {
            title = '';
            // rewind before spaces
            this.pos = beforetitle;
        }

        // make sure we're at line end:
        if (this.match(/^ *(?:\n|$)/) === null) {
            this.pos = startpos;
            return 0;
        }

        var normlabel = normalizeReference(rawlabel);

        if (!refmap[normlabel]) {
            refmap[normlabel] = { destination: dest, title: title };
        }
        return this.pos - startpos;
    };

    // Parse the next inline element in subject, advancing subject position.
    // If memoize is set, memoize the result.
    // On success, add the result to the inlines list, and return true.
    // On failure, return false.
    var parseInline = function(inlines, memoize) {
        var startpos = this.pos;
        var origlen = inlines.length;
        var memoized = memoize && this.memo[startpos];
        if (memoized) {
            this.pos = memoized.endpos;
            Array.prototype.push.apply(inlines, memoized.inline);
            return true;
        }

        var c = this.peek();
        if (c === -1) {
            return false;
        }
        var res;
        switch(c) {
        case C_NEWLINE:
        case C_SPACE:
            res = this.parseNewline(inlines);
            break;
        case C_BACKSLASH:
            res = this.parseBackslash(inlines);
            break;
        case C_BACKTICK:
            res = this.parseBackticks(inlines);
            break;
        case C_ASTERISK:
        case C_UNDERSCORE:
            res = this.parseEmphasis(c, inlines);
            break;
        case C_OPEN_BRACKET:
            res = this.parseLink(inlines);
            break;
        case C_BANG:
            res = this.parseImage(inlines);
            break;
        case C_LESSTHAN:
            res = this.parseAutolink(inlines) || this.parseHtmlTag(inlines);
            break;
        case C_AMPERSAND:
            res = this.parseEntity(inlines);
            break;
        default:
            res = this.parseString(inlines);
            break;
        }
        if (!res) {
            this.pos += 1;
            inlines.push({t: 'Str', c: String.fromCodePoint(c)});
        }

        if (memoize) {
            this.memo[startpos] = { inline: inlines.slice(origlen),
                                    endpos: this.pos };
        }
        return true;
    };

    // Parse s as a list of inlines, using refmap to resolve references.
    var parseInlines = function(s, refmap) {
        this.subject = s;
        this.pos = 0;
        this.refmap = refmap || {};
        this.memo = {};
        this.last_emphasis_closer = { '*': s.length, '_': s.length };
        var inlines = [];
        while (this.parseInline(inlines, false)) {
        }
        return inlines;
    };

    // The InlineParser object.
    function InlineParser(){
        return {
            subject: '',
            label_nest_level: 0, // used by parseLinkLabel method
            last_emphasis_closer: null,  // used by parseEmphasis method
            pos: 0,
            refmap: {},
            memo: {},
            match: match,
            peek: peek,
            spnl: spnl,
            parseBackticks: parseBackticks,
            parseBackslash: parseBackslash,
            parseAutolink: parseAutolink,
            parseHtmlTag: parseHtmlTag,
            scanDelims: scanDelims,
            parseEmphasis: parseEmphasis,
            parseLinkTitle: parseLinkTitle,
            parseLinkDestination: parseLinkDestination,
            parseLinkLabel: parseLinkLabel,
            parseLink: parseLink,
            parseEntity: parseEntity,
            parseString: parseString,
            parseNewline: parseNewline,
            parseImage: parseImage,
            parseReference: parseReference,
            parseInline: parseInline,
            parse: parseInlines
        };
    }

    // DOC PARSER

    // These are methods of a DocParser object, defined below.

    var makeBlock = function(tag, start_line, start_column) {
        return { t: tag,
                 open: true,
                 last_line_blank: false,
                 start_line: start_line,
                 start_column: start_column,
                 end_line: start_line,
                 children: [],
                 parent: null,
                 // string_content is formed by concatenating strings, in finalize:
                 string_content: "",
                 strings: [],
                 inline_content: []
               };
    };

    // Returns true if parent block can contain child block.
    var canContain = function(parent_type, child_type) {
        return ( parent_type == 'Document' ||
                 parent_type == 'BlockQuote' ||
                 parent_type == 'ListItem' ||
                 (parent_type == 'List' && child_type == 'ListItem') );
    };

    // Returns true if block type can accept lines of text.
    var acceptsLines = function(block_type) {
        return ( block_type == 'Paragraph' ||
                 block_type == 'IndentedCode' ||
                 block_type == 'FencedCode' );
    };

    // Returns true if block ends with a blank line, descending if needed
    // into lists and sublists.
    var endsWithBlankLine = function(block) {
        if (block.last_line_blank) {
            return true;
        }
        if ((block.t == 'List' || block.t == 'ListItem') && block.children.length > 0) {
            return endsWithBlankLine(block.children[block.children.length - 1]);
        } else {
            return false;
        }
    };

    // Break out of all containing lists, resetting the tip of the
    // document to the parent of the highest list, and finalizing
    // all the lists.  (This is used to implement the "two blank lines
    // break of of all lists" feature.)
    var breakOutOfLists = function(block, line_number) {
        var b = block;
        var last_list = null;
        do {
            if (b.t === 'List') {
                last_list = b;
            }
            b = b.parent;
        } while (b);

        if (last_list) {
            while (block != last_list) {
                this.finalize(block, line_number);
                block = block.parent;
            }
            this.finalize(last_list, line_number);
            this.tip = last_list.parent;
        }
    };

    // Add a line to the block at the tip.  We assume the tip
    // can accept lines -- that check should be done before calling this.
    var addLine = function(ln, offset) {
        var s = ln.slice(offset);
        if (!(this.tip.open)) {
            throw({ msg: "Attempted to add line (" + ln + ") to closed container." });
        }
        this.tip.strings.push(s);
    };

    // Add block of type tag as a child of the tip.  If the tip can't
    // accept children, close and finalize it and try its parent,
    // and so on til we find a block that can accept children.
    var addChild = function(tag, line_number, offset) {
        while (!canContain(this.tip.t, tag)) {
            this.finalize(this.tip, line_number);
        }

        var column_number = offset + 1; // offset 0 = column 1
        var newBlock = makeBlock(tag, line_number, column_number);
        this.tip.children.push(newBlock);
        newBlock.parent = this.tip;
        this.tip = newBlock;
        return newBlock;
    };

    // Parse a list marker and return data on the marker (type,
    // start, delimiter, bullet character, padding) or null.
    var parseListMarker = function(ln, offset) {
        var rest = ln.slice(offset);
        var match;
        var spaces_after_marker;
        var data = {};
        if (rest.match(reHrule)) {
            return null;
        }
        if ((match = rest.match(/^[*+-]( +|$)/))) {
            spaces_after_marker = match[1].length;
            data.type = 'Bullet';
            data.bullet_char = match[0][0];

        } else if ((match = rest.match(/^(\d+)([.)])( +|$)/))) {
            spaces_after_marker = match[3].length;
            data.type = 'Ordered';
            data.start = parseInt(match[1]);
            data.delimiter = match[2];
        } else {
            return null;
        }
        var blank_item = match[0].length === rest.length;
        if (spaces_after_marker >= 5 ||
            spaces_after_marker < 1 ||
            blank_item) {
            data.padding = match[0].length - spaces_after_marker + 1;
        } else {
            data.padding = match[0].length;
        }
        return data;
    };

    // Returns true if the two list items are of the same type,
    // with the same delimiter and bullet character.  This is used
    // in agglomerating list items into lists.
    var listsMatch = function(list_data, item_data) {
        return (list_data.type === item_data.type &&
                list_data.delimiter === item_data.delimiter &&
                list_data.bullet_char === item_data.bullet_char);
    };

    // Analyze a line of text and update the document appropriately.
    // We parse markdown text by calling this on each line of input,
    // then finalizing the document.
    var incorporateLine = function(ln, line_number) {

        var all_matched = true;
        var last_child;
        var first_nonspace;
        var offset = 0;
        var match;
        var data;
        var blank;
        var indent;
        var last_matched_container;
        var i;
        var CODE_INDENT = 4;

        var container = this.doc;
        var oldtip = this.tip;

        // Convert tabs to spaces:
        ln = detabLine(ln);

        // For each containing block, try to parse the associated line start.
        // Bail out on failure: container will point to the last matching block.
        // Set all_matched to false if not all containers match.
        while (container.children.length > 0) {
            last_child = container.children[container.children.length - 1];
            if (!last_child.open) {
                break;
            }
            container = last_child;

            match = matchAt(/[^ ]/, ln, offset);
            if (match === null) {
                first_nonspace = ln.length;
                blank = true;
            } else {
                first_nonspace = match;
                blank = false;
            }
            indent = first_nonspace - offset;

            switch (container.t) {
            case 'BlockQuote':
                if (indent <= 3 && ln.charCodeAt(first_nonspace) === C_GREATERTHAN) {
                    offset = first_nonspace + 1;
                    if (ln.charCodeAt(offset) === C_SPACE) {
                        offset++;
                    }
                } else {
                    all_matched = false;
                }
                break;

            case 'ListItem':
                if (indent >= container.list_data.marker_offset +
                    container.list_data.padding) {
                    offset += container.list_data.marker_offset +
                        container.list_data.padding;
                } else if (blank) {
                    offset = first_nonspace;
                } else {
                    all_matched = false;
                }
                break;

            case 'IndentedCode':
                if (indent >= CODE_INDENT) {
                    offset += CODE_INDENT;
                } else if (blank) {
                    offset = first_nonspace;
                } else {
                    all_matched = false;
                }
                break;

            case 'ATXHeader':
            case 'SetextHeader':
            case 'HorizontalRule':
                // a header can never container > 1 line, so fail to match:
                all_matched = false;
                break;

            case 'FencedCode':
                // skip optional spaces of fence offset
                i = container.fence_offset;
                while (i > 0 && ln.charCodeAt(offset) === C_SPACE) {
                    offset++;
                    i--;
                }
                break;

            case 'HtmlBlock':
                if (blank) {
                    all_matched = false;
                }
                break;

            case 'Paragraph':
                if (blank) {
                    container.last_line_blank = true;
                    all_matched = false;
                }
                break;

            default:
            }

            if (!all_matched) {
                container = container.parent; // back up to last matching block
                break;
            }
        }

        last_matched_container = container;

        // This function is used to finalize and close any unmatched
        // blocks.  We aren't ready to do this now, because we might
        // have a lazy paragraph continuation, in which case we don't
        // want to close unmatched blocks.  So we store this closure for
        // use later, when we have more information.
        var closeUnmatchedBlocks = function(mythis) {
            // finalize any blocks not matched
            while (!already_done && oldtip != last_matched_container) {
                mythis.finalize(oldtip, line_number);
                oldtip = oldtip.parent;
            }
            var already_done = true;
        };

        // Check to see if we've hit 2nd blank line; if so break out of list:
        if (blank && container.last_line_blank) {
            this.breakOutOfLists(container, line_number);
        }

        // Unless last matched container is a code block, try new container starts,
        // adding children to the last matched container:
        while (container.t != 'FencedCode' &&
               container.t != 'IndentedCode' &&
               container.t != 'HtmlBlock' &&
               // this is a little performance optimization:
               matchAt(/^[ #`~*+_=<>0-9-]/,ln,offset) !== null) {

            match = matchAt(/[^ ]/, ln, offset);
            if (match === null) {
                first_nonspace = ln.length;
                blank = true;
            } else {
                first_nonspace = match;
                blank = false;
            }
            indent = first_nonspace - offset;

            if (indent >= CODE_INDENT) {
                // indented code
                if (this.tip.t != 'Paragraph' && !blank) {
                    offset += CODE_INDENT;
                    closeUnmatchedBlocks(this);
                    container = this.addChild('IndentedCode', line_number, offset);
                } else { // indent > 4 in a lazy paragraph continuation
                    break;
                }

            } else if (ln.charCodeAt(first_nonspace) === C_GREATERTHAN) {
                // blockquote
                offset = first_nonspace + 1;
                // optional following space
                if (ln.charCodeAt(offset) === C_SPACE) {
                    offset++;
                }
                closeUnmatchedBlocks(this);
                container = this.addChild('BlockQuote', line_number, offset);

            } else if ((match = ln.slice(first_nonspace).match(/^#{1,6}(?: +|$)/))) {
                // ATX header
                offset = first_nonspace + match[0].length;
                closeUnmatchedBlocks(this);
                container = this.addChild('ATXHeader', line_number, first_nonspace);
                container.level = match[0].trim().length; // number of #s
                // remove trailing ###s:
                container.strings =
                    [ln.slice(offset).replace(/(?:(\\#) *#*| *#+) *$/,'$1')];
                break;

            } else if ((match = ln.slice(first_nonspace).match(/^`{3,}(?!.*`)|^~{3,}(?!.*~)/))) {
                // fenced code block
                var fence_length = match[0].length;
                closeUnmatchedBlocks(this);
                container = this.addChild('FencedCode', line_number, first_nonspace);
                container.fence_length = fence_length;
                container.fence_char = match[0][0];
                container.fence_offset = first_nonspace - offset;
                offset = first_nonspace + fence_length;
                break;

            } else if (matchAt(reHtmlBlockOpen, ln, first_nonspace) !== null) {
                // html block
                closeUnmatchedBlocks(this);
                container = this.addChild('HtmlBlock', line_number, first_nonspace);
                // note, we don't adjust offset because the tag is part of the text
                break;

            } else if (container.t == 'Paragraph' &&
                       container.strings.length === 1 &&
                       ((match = ln.slice(first_nonspace).match(/^(?:=+|-+) *$/)))) {
                // setext header line
                closeUnmatchedBlocks(this);
                container.t = 'SetextHeader'; // convert Paragraph to SetextHeader
                container.level = match[0][0] === '=' ? 1 : 2;
                offset = ln.length;

            } else if (matchAt(reHrule, ln, first_nonspace) !== null) {
                // hrule
                closeUnmatchedBlocks(this);
                container = this.addChild('HorizontalRule', line_number, first_nonspace);
                offset = ln.length - 1;
                break;

            } else if ((data = parseListMarker(ln, first_nonspace))) {
                // list item
                closeUnmatchedBlocks(this);
                data.marker_offset = indent;
                offset = first_nonspace + data.padding;

                // add the list if needed
                if (container.t !== 'List' ||
                    !(listsMatch(container.list_data, data))) {
                    container = this.addChild('List', line_number, first_nonspace);
                    container.list_data = data;
                }

                // add the list item
                container = this.addChild('ListItem', line_number, first_nonspace);
                container.list_data = data;

            } else {
                break;

            }

            if (acceptsLines(container.t)) {
                // if it's a line container, it can't contain other containers
                break;
            }
        }

        // What remains at the offset is a text line.  Add the text to the
        // appropriate container.

        match = matchAt(/[^ ]/, ln, offset);
        if (match === null) {
            first_nonspace = ln.length;
            blank = true;
        } else {
            first_nonspace = match;
            blank = false;
        }
        indent = first_nonspace - offset;

        // First check for a lazy paragraph continuation:
        if (this.tip !== last_matched_container &&
            !blank &&
            this.tip.t == 'Paragraph' &&
            this.tip.strings.length > 0) {
            // lazy paragraph continuation

            this.last_line_blank = false;
            this.addLine(ln, offset);

        } else { // not a lazy continuation

            // finalize any blocks not matched
            closeUnmatchedBlocks(this);

            // Block quote lines are never blank as they start with >
            // and we don't count blanks in fenced code for purposes of tight/loose
            // lists or breaking out of lists.  We also don't set last_line_blank
            // on an empty list item.
            container.last_line_blank = blank &&
                !(container.t == 'BlockQuote' ||
                  container.t == 'FencedCode' ||
                  (container.t == 'ListItem' &&
                   container.children.length === 0 &&
                   container.start_line == line_number));

            var cont = container;
            while (cont.parent) {
                cont.parent.last_line_blank = false;
                cont = cont.parent;
            }

            switch (container.t) {
            case 'IndentedCode':
            case 'HtmlBlock':
                this.addLine(ln, offset);
                break;

            case 'FencedCode':
                // check for closing code fence:
                match = (indent <= 3 &&
                         ln.charAt(first_nonspace) == container.fence_char &&
                         ln.slice(first_nonspace).match(/^(?:`{3,}|~{3,})(?= *$)/));
                if (match && match[0].length >= container.fence_length) {
                    // don't add closing fence to container; instead, close it:
                    this.finalize(container, line_number);
                } else {
                    this.addLine(ln, offset);
                }
                break;

            case 'ATXHeader':
            case 'SetextHeader':
            case 'HorizontalRule':
                // nothing to do; we already added the contents.
                break;

            default:
                if (acceptsLines(container.t)) {
                    this.addLine(ln, first_nonspace);
                } else if (blank) {
                    // do nothing
                } else if (container.t != 'HorizontalRule' &&
                           container.t != 'SetextHeader') {
                    // create paragraph container for line
                    container = this.addChild('Paragraph', line_number, first_nonspace);
                    this.addLine(ln, first_nonspace);
                } else {
                    console.log("Line " + line_number.toString() +
                                " with container type " + container.t +
                                " did not match any condition.");

                }
            }
        }
    };

    // Finalize a block.  Close it and do any necessary postprocessing,
    // e.g. creating string_content from strings, setting the 'tight'
    // or 'loose' status of a list, and parsing the beginnings
    // of paragraphs for reference definitions.  Reset the tip to the
    // parent of the closed block.
    var finalize = function(block, line_number) {
        var pos;
        // don't do anything if the block is already closed
        if (!block.open) {
            return 0;
        }
        block.open = false;
        if (line_number > block.start_line) {
            block.end_line = line_number - 1;
        } else {
            block.end_line = line_number;
        }

        switch (block.t) {
        case 'Paragraph':
            block.string_content = block.strings.join('\n').replace(/^  */m,'');

            // try parsing the beginning as link reference definitions:
            while (block.string_content.charCodeAt(0) === C_OPEN_BRACKET &&
                   (pos = this.inlineParser.parseReference(block.string_content,
                                                           this.refmap))) {
                block.string_content = block.string_content.slice(pos);
                if (isBlank(block.string_content)) {
                    block.t = 'ReferenceDef';
                    break;
                }
            }
            break;

        case 'ATXHeader':
        case 'SetextHeader':
        case 'HtmlBlock':
            block.string_content = block.strings.join('\n');
            break;

        case 'IndentedCode':
            block.string_content = block.strings.join('\n').replace(/(\n *)*$/,'\n');
            break;

        case 'FencedCode':
            // first line becomes info string
            block.info = unescapeEntBS(block.strings[0].trim());
            if (block.strings.length == 1) {
                block.string_content = '';
            } else {
                block.string_content = block.strings.slice(1).join('\n') + '\n';
            }
            break;

        case 'List':
            block.tight = true; // tight by default

            var numitems = block.children.length;
            var i = 0;
            while (i < numitems) {
                var item = block.children[i];
                // check for non-final list item ending with blank line:
                var last_item = i == numitems - 1;
                if (endsWithBlankLine(item) && !last_item) {
                    block.tight = false;
                    break;
                }
                // recurse into children of list item, to see if there are
                // spaces between any of them:
                var numsubitems = item.children.length;
                var j = 0;
                while (j < numsubitems) {
                    var subitem = item.children[j];
                    var last_subitem = j == numsubitems - 1;
                    if (endsWithBlankLine(subitem) && !(last_item && last_subitem)) {
                        block.tight = false;
                        break;
                    }
                    j++;
                }
                i++;
            }
            break;

        default:
            break;
        }

        this.tip = block.parent || this.top;
    };

    // Walk through a block & children recursively, parsing string content
    // into inline content where appropriate.
    var processInlines = function(block) {
        switch(block.t) {
        case 'Paragraph':
        case 'SetextHeader':
        case 'ATXHeader':
            block.inline_content =
                this.inlineParser.parse(block.string_content.trim(), this.refmap);
            block.string_content = "";
            break;
        default:
            break;
        }

        if (block.children) {
            for (var i = 0; i < block.children.length; i++) {
                this.processInlines(block.children[i]);
            }
        }

    };

    // The main parsing function.  Returns a parsed document AST.
    var parse = function(input) {
        this.doc = makeBlock('Document', 1, 1);
        this.tip = this.doc;
        this.refmap = {};
        var lines = input.replace(/\n$/,'').split(/\r\n|\n|\r/);
        var len = lines.length;
        for (var i = 0; i < len; i++) {
            this.incorporateLine(lines[i], i+1);
        }
        while (this.tip) {
            this.finalize(this.tip, len - 1);
        }
        this.processInlines(this.doc);
        return this.doc;
    };


    // The DocParser object.
    function DocParser(){
        return {
            doc: makeBlock('Document', 1, 1),
            tip: this.doc,
            refmap: {},
            inlineParser: new InlineParser(),
            breakOutOfLists: breakOutOfLists,
            addLine: addLine,
            addChild: addChild,
            incorporateLine: incorporateLine,
            finalize: finalize,
            processInlines: processInlines,
            parse: parse
        };
    }

    // HTML RENDERER

    // Helper function to produce content in a pair of HTML tags.
    var inTags = function(tag, attribs, contents, selfclosing) {
        var result = '<' + tag;
        if (attribs) {
            var i = 0;
            var attrib;
            while ((attrib = attribs[i]) !== undefined) {
                result = result.concat(' ', attrib[0], '="', attrib[1], '"');
                i++;
            }
        }
        if (contents) {
            result = result.concat('>', contents, '</', tag, '>');
        } else if (selfclosing) {
            result = result + ' />';
        } else {
            result = result.concat('></', tag, '>');
        }
        return result;
    };

    // Render an inline element as HTML.
    var renderInline = function(inline) {
        var attrs;
        switch (inline.t) {
        case 'Str':
            return this.escape(inline.c);
        case 'Softbreak':
            return this.softbreak;
        case 'Hardbreak':
            return inTags('br',[],"",true) + '\n';
        case 'Emph':
            return inTags('em', [], this.renderInlines(inline.c));
        case 'Strong':
            return inTags('strong', [], this.renderInlines(inline.c));
        case 'Html':
            return inline.c;
        case 'Link':
            attrs = [['href', this.escape(inline.destination, true)]];
            if (inline.title) {
                attrs.push(['title', this.escape(inline.title, true)]);
            }
            return inTags('a', attrs, this.renderInlines(inline.label));
        case 'Image':
            attrs = [['src', this.escape(inline.destination, true)],
                     ['alt', this.escape(this.renderInlines(inline.label))]];
            if (inline.title) {
                attrs.push(['title', this.escape(inline.title, true)]);
            }
            return inTags('img', attrs, "", true);
        case 'Code':
            return inTags('code', [], this.escape(inline.c));
        default:
            console.log("Unknown inline type " + inline.t);
            return "";
        }
    };

    // Render a list of inlines.
    var renderInlines = function(inlines) {
        var result = '';
        for (var i=0; i < inlines.length; i++) {
            result = result + this.renderInline(inlines[i]);
        }
        return result;
    };

    // Render a single block element.
    var renderBlock = function(block, in_tight_list) {
        var tag;
        var attr;
        var info_words;
        switch (block.t) {
        case 'Document':
            var whole_doc = this.renderBlocks(block.children);
            return (whole_doc === '' ? '' : whole_doc + '\n');
        case 'Paragraph':
            if (in_tight_list) {
                return this.renderInlines(block.inline_content);
            } else {
                return inTags('p', [], this.renderInlines(block.inline_content));
            }
            break;
        case 'BlockQuote':
            var filling = this.renderBlocks(block.children);
            return inTags('blockquote', [], filling === '' ? this.innersep :
                          this.innersep + filling + this.innersep);
        case 'ListItem':
            return inTags('li', [], this.renderBlocks(block.children, in_tight_list).trim());
        case 'List':
            tag = block.list_data.type == 'Bullet' ? 'ul' : 'ol';
            attr = (!block.list_data.start || block.list_data.start == 1) ?
                [] : [['start', block.list_data.start.toString()]];
            return inTags(tag, attr, this.innersep +
                          this.renderBlocks(block.children, block.tight) +
                          this.innersep);
        case 'ATXHeader':
        case 'SetextHeader':
            tag = 'h' + block.level;
            return inTags(tag, [], this.renderInlines(block.inline_content));
        case 'IndentedCode':
            return inTags('pre', [],
                          inTags('code', [], this.escape(block.string_content)));
        case 'FencedCode':
            info_words = block.info.split(/ +/);
            attr = info_words.length === 0 || info_words[0].length === 0 ?
                [] : [['class','language-' +
                       this.escape(info_words[0],true)]];
            return inTags('pre', [],
                          inTags('code', attr, this.escape(block.string_content)));
        case 'HtmlBlock':
            return block.string_content;
        case 'ReferenceDef':
            return "";
        case 'HorizontalRule':
            return inTags('hr',[],"",true);
        default:
            console.log("Unknown block type " + block.t);
            return "";
        }
    };

    // Render a list of block elements, separated by this.blocksep.
    var renderBlocks = function(blocks, in_tight_list) {
        var result = [];
        for (var i=0; i < blocks.length; i++) {
            if (blocks[i].t !== 'ReferenceDef') {
                result.push(this.renderBlock(blocks[i], in_tight_list));
            }
        }
        return result.join(this.blocksep);
    };

    // The HtmlRenderer object.
    function HtmlRenderer(){
        return {
            // default options:
            blocksep: '\n',  // space between blocks
            innersep: '\n',  // space between block container tag and contents
            softbreak: '\n', // by default, soft breaks are rendered as newlines in HTML
            // set to "<br />" to make them hard breaks
            // set to " " if you want to ignore line wrapping in source
            escape: function(s, preserve_entities) {
                if (preserve_entities) {
                    return s.replace(/[&](?![#](x[a-f0-9]{1,8}|[0-9]{1,8});|[a-z][a-z0-9]{1,31};)/gi,'&amp;')
                        .replace(/[<]/g,'&lt;')
                        .replace(/[>]/g,'&gt;')
                        .replace(/["]/g,'&quot;');
                } else {
                    return s.replace(/[&]/g,'&amp;')
                        .replace(/[<]/g,'&lt;')
                        .replace(/[>]/g,'&gt;')
                        .replace(/["]/g,'&quot;');
                }
            },
            renderInline: renderInline,
            renderInlines: renderInlines,
            renderBlock: renderBlock,
            renderBlocks: renderBlocks,
            render: renderBlock
        };
    }

    exports.DocParser = DocParser;
    exports.HtmlRenderer = HtmlRenderer;

})(typeof exports === 'undefined' ? this.stmd = {} : exports);
